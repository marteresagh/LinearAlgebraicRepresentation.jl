var documenterSearchIndex = {"docs":
[{"location":"#Lar.jl-1","page":"Home","title":"Lar.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Lar.jl is a Julia library to perform geometrical computations on cellular complexes expressed through the Linear Algebraic Representation (LAR). This library is developed and maintained by the Computational Visual Design Laboratory (CVDLAB) of Universit√† degli Studi di Roma Tre.","category":"page"},{"location":"#Dependencies-1","page":"Home","title":"Dependencies","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Lar.jl has several Julia dependencies:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"NearestNeighbors\nDataStructures\nIntervalTrees\nTriangle","category":"page"},{"location":"#Docstrings-conventions-1","page":"Home","title":"Docstrings conventions","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Bold is used to point out theory concepts. For example, look at the  \"1-skeletons\" word in the docstring of Lar.skel_merge:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Lar.skel_merge(V1::Lar.Points, EV1::Lar.ChainOp, V2::Lar.Points, EV2::Lar.ChainOp)","category":"page"},{"location":"#LinearAlgebraicRepresentation.skel_merge-Tuple{Array{T,2} where T,SparseArrays.SparseMatrixCSC{Int8,Int64},Array{T,2} where T,SparseArrays.SparseMatrixCSC{Int8,Int64}}","page":"Home","title":"LinearAlgebraicRepresentation.skel_merge","text":"skel_merge(V1::Points, EV1::ChainOp, V2::Points, EV2::ChainOp)\n\nMerge two 1-skeletons\n\n\n\n\n\n","category":"method"},{"location":"#","page":"Home","title":"Home","text":"Monospace is used for everything code related. Look this time at \"container\", \"contained\" and \"Points\" in the docstring of Lar.bbox_contains:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Lar.bbox_contains","category":"page"},{"location":"#LinearAlgebraicRepresentation.bbox_contains","page":"Home","title":"LinearAlgebraicRepresentation.bbox_contains","text":"bbox_contains(container, contained)\n\nCheck if the axis aligned bounding box container contains contained.\n\nEach input box must be passed as the couple of Points standing on the opposite corners of the box.\n\n\n\n\n\n","category":"function"},{"location":"#","page":"Home","title":"Home","text":"note: Note\nIn Julia REPL the monospace text is the one colored differently. In a terminal you will see something like:   (Image: Julia REPL monospace exaple)","category":"page"},{"location":"lar/#LAR-1","page":"L.A.R. Intro","title":"LAR","text":"","category":"section"},{"location":"lar/#","page":"L.A.R. Intro","title":"L.A.R. Intro","text":"LAR is a general representation scheme for geometric and topological modeling (see \"Linear algebraic representation for topological structures\"). The domain of the scheme is provided by cellular complexes while its codomain is a set of sparse matrices. The main advantages of the scheme are:","category":"page"},{"location":"lar/#","page":"L.A.R. Intro","title":"L.A.R. Intro","text":"It is extremely effective to easily represent general non-manifold solids.  For example, the memory representation of a d=3 cellular complex using LAR consists in only two binary sparse matrices for the topology and a bi-dimensional array for the geometry.\nComputation and analysis of cellular complexes is done only through easy linear algebra operations.  The most common operation is the sparse matrix-vector multiplication.","category":"page"},{"location":"lar/#","page":"L.A.R. Intro","title":"L.A.R. Intro","text":"Here a list of fundamental concepts and features of LAR: ","category":"page"},{"location":"lar/#LAR-model-1","page":"L.A.R. Intro","title":"LAR model","text":"","category":"section"},{"location":"lar/#","page":"L.A.R. Intro","title":"L.A.R. Intro","text":"A LAR model is a pair geometry, topology.  The geometry is specified by the position vectors of vertices in a Euclidean  space mathbbE^d of points with d coordinates. The topology is specified by one  or more bases of singleton k-chains (i.e.~k-cells) for 0 leq kleq d.  The vertex sharing between cells implicitly provides the attachment maps between  cells of various dimensions. Vertex positions are represented, by columns, by a  2-array of d real coordinates.","category":"page"},{"location":"lar/#Chains-as-arrays-1","page":"L.A.R. Intro","title":"Chains as arrays","text":"","category":"section"},{"location":"lar/#","page":"L.A.R. Intro","title":"L.A.R. Intro","text":"Chain-based modeling and computing (refer to \"Chain-Based Representations for Solid and Physical Modeling\")  is based on representation of p-cell subsets as chains, elements of linear spaces C_p (0leq pleq d) generated by the space decomposition induced by a cellular complex, also said CW-complex. Chains can be simply represented as arrays of signed integers, one of simplest and more efficient data structure of most languages, particularly when oriented to scientific computing. Therefore, basic algebraic operations on chains as  vectors (sum and product times a scalar) are implemented over arrays.","category":"page"},{"location":"lar/#Characteristic-matrices-1","page":"L.A.R. Intro","title":"Characteristic matrices","text":"","category":"section"},{"location":"lar/#","page":"L.A.R. Intro","title":"L.A.R. Intro","text":"The LAR representation scheme, i.e. our  mapping between mathematical models of solids and their computer representations, uses linear chain spaces C_p as models, and sparse characteristic matrices M_p of p-cells as symbolic representations, where the p-cell sigma^kinLambda_p is represented as the k-th binary row of the sparse characteristic matrix M_p C_0to C_p.","category":"page"},{"location":"lar/#Boundary-and-coboundary-matrices-1","page":"L.A.R. Intro","title":"Boundary and coboundary matrices","text":"","category":"section"},{"location":"lar/#","page":"L.A.R. Intro","title":"L.A.R. Intro","text":"The boundary matrix partial_p is the matrix of the boundary operator  partial_p C_pto C_p-1 (1leq pleq d) that for each chain c_pin C_p  returns the boundary (p-1)-cycle of its (d-1)-faces. A boundary operator is linear:  partial_p c + d = partial_p c + partial_p d, for each cdin C_p. A cycle is a  chain without boundary. Hence, the boundary of a boundary is the zero map:  partial_p-1 circ partial_p = 0 (2leq pleq d).","category":"page"},{"location":"lar/#Incidence-matrices-1","page":"L.A.R. Intro","title":"Incidence matrices","text":"","category":"section"},{"location":"lar/#","page":"L.A.R. Intro","title":"L.A.R. Intro","text":"Incidence operators between chain spaces of different dimension are easy to compute by matrix products of characteristic matrices, possibly transposed. Since both characteristic and operator matrices are very sparse, their products are computed  with specialized algorithms for sparse matrices, whose complexity is roughly linear in the size  of the output sparse matrix, i.e., in the number of its stored non-zero elements. Incidence queries and other types of geometric or topological computations are not  performed element-wise, that necessarily require iterative or recursive programming patterns,  but only require matrix product times whole chains (sets of cells), so adapting naturally to parallel and/or dataflow computational patterns found in HPC and CNN architectures.","category":"page"},{"location":"lar/#Validity-test-of-a-representation-1","page":"L.A.R. Intro","title":"Validity test of a representation","text":"","category":"section"},{"location":"lar/#","page":"L.A.R. Intro","title":"L.A.R. Intro","text":"Data validity is easy to test by checking for satisfaction of basic equations  partialpartial=emptyset of a chain complex.","category":"page"},{"location":"lar/#Space-arrangments-1","page":"L.A.R. Intro","title":"Space arrangments","text":"","category":"section"},{"location":"lar/#","page":"L.A.R. Intro","title":"L.A.R. Intro","text":"Given a finite collection mathcalS of cellular complexes in mathbbE^d, d in 23, the \\emph{arrangement} mathcalA(mathcalS) is the decomposition of mathbbE^d into connected cells of dimensions 0 1 ldots d  induced by mathcalS. In Lar.jl, we provide an efficient computation of the arrangement produced by a given set of cellular complexes in either 2D or 3D.  The goal here is to provide a complete description of the plane or space decomposition  induced by the input, into cells of dimensions 0, 1, 2 or 3. This computation is based  on the algorithms introduced in \\cite{DBLP:journals/corr/PaoluzziSD17} which describe how  to compute the d-space arrangement generated by a collection of (d-1)-complexes.  A general description of both the motivations and the features of the space arrangement  and Lar.jl in general are given in~\\cite{DBLP:journals/corr/abs-1710-07819}.","category":"page"},{"location":"lar/#","page":"L.A.R. Intro","title":"L.A.R. Intro","text":"With abuse of language, we consider a finite cellular complex X as generated by a discrete  partition of an Euclidean space. In computing a cellular complex as the space arrangement of  a collection of geometric objects mathcalS, i.e. when  X = mathcalA(mathcalS),  we actually compute the whole chain complex C_bullet generated by X, i.e.:","category":"page"},{"location":"lar/#","page":"L.A.R. Intro","title":"L.A.R. Intro","text":"(Image: chains)","category":"page"},{"location":"lar/#","page":"L.A.R. Intro","title":"L.A.R. Intro","text":"where C_p (0geq pgeq 3) is a linear space of \\emph{p-chains} (subsets of p-cells  with algebraic structure). The linear operators partial_p and delta_p are the boundary  and coboundary operators as described before, respectively with","category":"page"},{"location":"lar/#","page":"L.A.R. Intro","title":"L.A.R. Intro","text":"partial_p-1circpartial_p  = emptyset = delta_pcircdelta_p-1","category":"page"},{"location":"lar/#","page":"L.A.R. Intro","title":"L.A.R. Intro","text":"and where ","category":"page"},{"location":"lar/#","page":"L.A.R. Intro","title":"L.A.R. Intro","text":"delta_p-1 = partial_p^top quad 1leq pleq 3","category":"page"},{"location":"interface/#Interface-to-cell-and-chain-complexes-1","page":"Interface","title":"Interface to cell and chain complexes","text":"","category":"section"},{"location":"interface/#","page":"Interface","title":"Interface","text":"Most part of text in this page is derived from  and from .","category":"page"},{"location":"interface/#Introduction-1","page":"Interface","title":"Introduction","text":"","category":"section"},{"location":"interface/#","page":"Interface","title":"Interface","text":"With increased complexity of geometric data, topological models play an increasingly important role beyond boundary representations, assemblies, finite elements, image processing, and other traditional modeling applications. While many graph- and index- based data structures have been proposed, no standard representation has emerged as of now. Furthermore, such representations typically do not deal with representations of mappings and functions and do not scale to support parallel processing, open source, and client-based architectures. ","category":"page"},{"location":"interface/#","page":"Interface","title":"Interface","text":"A proper mathematical model for all topological structures is a (co)chain complex: a sequence of linear (co)chain spaces and linear (co)boundary mappings. This in turn implies all topological structures may be represented by a collection of sparse matrices. We propose a Linear Algebraic Representation (LAR) scheme for mod 2 (co)chain complexes using CSC sparse matrices and show that it supports variety of topological computations using standard matrix algebra, without any overhead in space or running time. With the LAR scheme, only the characteristic functions (see below) of d-cells as vertex subsets are necessary for representing polytopal complexes. Examples include simplicial, cubical, and Voronoi complexes.","category":"page"},{"location":"interface/#Data-structures-1","page":"Interface","title":"Data structures","text":"","category":"section"},{"location":"interface/#","page":"Interface","title":"Interface","text":"All types of cell complexes and functions over cell complexes are properly represented by a (co)chain complex, that captures all combinatorial relationships of interest in solid and physical modeling formally and unambiguously. According to classical results from algebraic topology techniques, a (co)chain complex and all associated combinatorial operations are readily represented using standard techniques from linear algebra, giving rise to a Linear Algebraic Represention (LAR) scheme.","category":"page"},{"location":"interface/#","page":"Interface","title":"Interface","text":"In this package, we provide LAR data structures and algorithms using compressed sparse column (CSC) matrices, that introduce no computational overhead and are asymptotically as efficient as (and usually better than) many other popular topological data structures. Our aim is to provide a representation that supports all topological constructions and queries that arise in typical cellular decomposition of space (mesh, image, boundary, etc).","category":"page"},{"location":"interface/#","page":"Interface","title":"Interface","text":"An arrangement is the decomposition of d-dimensional space into connected and relatively open cells of lower dimensions, induced by an intersection of a finite collection of geometric objects. A planar collection S may include line segments, open or closed polygonal lines, polygons, two-dimensional meshes, and discrete images in 2D. A space collection may include 3D polygons, polygonal meshes, B-reps of solid models‚Äîeither manifold or non-manifold, three-dimensional CAE meshes, and volumetric images in 3D.","category":"page"},{"location":"interface/#","page":"Interface","title":"Interface","text":"In this package, we have implemented the computation of the arrangement produced by a  set of cellular complexes in either 2D or 3D. Our goal is to provide a complete description of the plane or space decomposition induced by the input, into cells of dimensions 0, 1, 2 or 3.","category":"page"},{"location":"interface/#Characteristic-matrices-1","page":"Interface","title":"Characteristic matrices","text":"","category":"section"},{"location":"interface/#","page":"Interface","title":"Interface","text":"A precise mathematical definition of a cellular complex is not trivial; we may rely on the intuitive idea of constructing a space by gluing together a number of building blocks of different dimensions, called cells.","category":"page"},{"location":"interface/#","page":"Interface","title":"Interface","text":"The characteristic function chi _A  S to  0 1  is a function defined on a set S = s_j, that indicates membership of an element s_j in a subset A subseteq S, having the value 1 for all elements of A and the value 0 for all elements of S not in A. We call characteristic matrix M of a collection of subsets A_i subseteq S  (i=1n) the binary matrix M=(m_ij), with m_ij = chi_A_i(s_j).","category":"page"},{"location":"interface/#Examples-1","page":"Interface","title":"Examples","text":"","category":"section"},{"location":"interface/#","page":"Interface","title":"Interface","text":"Binary matrix representing by rows the p-cells of a cellular complex. The input parameter must be of Cells type. Return a sparse binary matrix,  providing the basis of a Chain space of given dimension. Notice that the  number of columns is equal to the number of vertices (0-cells). ","category":"page"},{"location":"interface/#","page":"Interface","title":"Interface","text":"First the cellular complex describing the 0-, 1-, 2-, anf 3-faces of a single unit cube is generated. ","category":"page"},{"location":"interface/#","page":"Interface","title":"Interface","text":"V,(VV,EV,FV,CV) = Lar.cuboid([1.,1.,1.], true); ","category":"page"},{"location":"interface/#","page":"Interface","title":"Interface","text":"Then, we may see the characteristic matrix of 1-cells (edges), with two ones per row:","category":"page"},{"location":"interface/#","page":"Interface","title":"Interface","text":"julia> Lar = LinearAlgebraicRepresentation\n\njulia> Matrix(Lar.characteristicMatrix(EV))\n12√ó8 Array{Int8,2}:\n 1  1  0  0  0  0  0  0\n 0  0  1  1  0  0  0  0\n 0  0  0  0  1  1  0  0\n 0  0  0  0  0  0  1  1\n 1  0  1  0  0  0  0  0\n 0  1  0  1  0  0  0  0\n 0  0  0  0  1  0  1  0\n 0  0  0  0  0  1  0  1\n 1  0  0  0  1  0  0  0\n 0  1  0  0  0  1  0  0\n 0  0  1  0  0  0  1  0\n 0  0  0  1  0  0  0  1","category":"page"},{"location":"interface/#","page":"Interface","title":"Interface","text":"and of 2-cells (faces):","category":"page"},{"location":"interface/#","page":"Interface","title":"Interface","text":"julia> Matrix(Lar.characteristicMatrix(FV))\n6√ó8 Array{Int8,2}:\n 1  1  1  1  0  0  0  0\n 0  0  0  0  1  1  1  1\n 1  1  0  0  1  1  0  0\n 0  0  1  1  0  0  1  1\n 1  0  1  0  1  0  1  0\n 0  1  0  1  0  1  0  1","category":"page"},{"location":"interface/#","page":"Interface","title":"Interface","text":"Finally, the boundary of the single 3-cell contains all the 0-cells (vertices). Of course, the 3D cube has 12 edges in EV, 6 faces in FV, and one 3-cell in CV:","category":"page"},{"location":"interface/#","page":"Interface","title":"Interface","text":"julia> Matrix(Lar.characteristicMatrix(CV))\n1√ó8 Array{Int8,2}:\n 1  1  1  1  1  1  1  1","category":"page"},{"location":"interface/#Chain-bases-1","page":"Interface","title":"Chain bases","text":"","category":"section"},{"location":"interface/#","page":"Interface","title":"Interface","text":"In algebraic topology, a k-chain is a formal linear combination of the k-cells in a cell complex. In simplicial complexes (respectively, cubical complexes), k-chains are combinations of k-simplices (respectively, k-cubes).","category":"page"},{"location":"interface/#","page":"Interface","title":"Interface","text":"Let sigma be an oriented cell in X and mu in G. The elementary chain whose value is mu on sigma, -mu on -sigma and 0 on any other cell in X is denoted musigma . Each chain can then be written in a unique way as a sum of elementary chains. With abuse of notation, we do NOT distinguish between cells and singleton chains (i.e., the elementary chains whose value is 1sigma for some cell sigma), used as elements of the standard bases of chain groups.","category":"page"},{"location":"interface/#","page":"Interface","title":"Interface","text":"Chains are often thought of as attaching orientation and multiplicity to cells: if coefficients are extracted from the group G = ( 1 0 1  +)  (mathbfZ_3 +), then cells can only be discarded or selected, possibly inverting their orientation.  A p-cycle is a closed p-chain, i.e. a p-chain without boundary.  It is useful to select a conventional choice to orient the singleton chains (single cells) automatically. 0-cells are considered all positive. The p-cells, for 1  p  d-1, can be given an internal orientation according to the orientation of the first (p  1)-cell in their canonical representation, i.e. sorted on indices of their (p  1)-cycle. Finally, a d-cell may be oriented as the sign of its oriented volume.","category":"page"},{"location":"interface/#Examples-2","page":"Interface","title":"Examples","text":"","category":"section"},{"location":"interface/#","page":"Interface","title":"Interface","text":"A compact representation of bases of p-cells is provided by Cells type, defined as Array{Array{Int,1}}, where each element codifies a cell as the array of indices to vertices on the boundary of the cell:","category":"page"},{"location":"interface/#","page":"Interface","title":"Interface","text":"julia> V,(VV,EV,FV,CV) = Lar.cuboid([1.,1.,1.], true);\n\njulia> FV\n6-element Array{Array{Int64,1},1}:\n [1, 2, 3, 4]\n [5, 6, 7, 8]\n [1, 2, 5, 6]\n [3, 4, 7, 8]\n [1, 3, 5, 7]\n [2, 4, 6, 8]","category":"page"},{"location":"interface/#","page":"Interface","title":"Interface","text":"A simplicial decomposition of the unit cube with six 3-cells (tetrahedra), and a simplicial decomposition of the domain 05 times 01 with ten 2-cells (triangles) follows:","category":"page"},{"location":"interface/#","page":"Interface","title":"Interface","text":"julia> V,CV = Lar.simplexGrid([1,1,1]);\n\njulia> V\n3√ó8 Array{Float64,2}:\n 0.0  1.0  0.0  1.0  0.0  1.0  0.0  1.0\n 0.0  0.0  1.0  1.0  0.0  0.0  1.0  1.0\n 0.0  0.0  0.0  0.0  1.0  1.0  1.0  1.0\n\njulia> CV   # bases of tetrahedra\n6-element Array{Array{Int64,1},1}:\n [1, 2, 3, 5]\n [2, 3, 5, 6]\n [3, 5, 6, 7]\n [2, 3, 4, 6]\n [3, 4, 6, 7]\n [4, 6, 7, 8]\n\njulia> W,FW = Lar.simplexGrid([5,1]);\n\njulia> W\n2√ó12 Array{Float64,2}:\n 0.0  1.0  2.0  3.0  4.0  5.0  0.0  1.0  2.0  3.0  4.0  5.0\n 0.0  0.0  0.0  0.0  0.0  0.0  1.0  1.0  1.0  1.0  1.0  1.0\n\njulia> FW   # bases of triangles\n10-element Array{Array{Int64,1},1}:\n [1, 2, 7]  \n [2, 7, 8]  \n [2, 3, 8]  \n [3, 8, 9]  \n [3, 4, 9]  \n [4, 9, 10] \n [4, 5, 10] \n [5, 10, 11]\n [5, 6, 11] \n [6, 11, 12]","category":"page"},{"location":"interface/#","page":"Interface","title":"Interface","text":"It is worthwhile to note that the above examples provide p-bases of suitable dimensions, equal to the number of p-cells,  for the corresponding chain complexes.   ","category":"page"},{"location":"interface/#(Co)boundary-operators-1","page":"Interface","title":"(Co)boundary operators","text":"","category":"section"},{"location":"interface/#","page":"Interface","title":"Interface","text":"Boundary operators are maps partial_p  C_p to C_p1 between chain spaces, i.e. between spaces of subsets of cells with different dimension, with 1 leq p leq d, hence for a cellular 2-complex we have two operators, denoted as partial_2  C_2 to C_1 and partial_1  C_1 to C_0, respectively. Since they are linear maps between linear spaces, may be represented by matrices of coefficients partial_2 and partial_1 from the corresponding groups. We use the groups 0 1 and -1 0 1 for unsigned and signed coefficients, respectively.","category":"page"},{"location":"interface/#","page":"Interface","title":"Interface","text":"The concept of cochain  in a group C^p of linear maps from chains C_p to Re allows for the association of numbers not only to single cells, as done by chains, but also to assemblies of cells. A cochain is hence the association of every discretized subdomain (chain) of a cell complex with a numeric quantity, usually resulting from a discrete integration over a chain.","category":"page"},{"location":"interface/#","page":"Interface","title":"Interface","text":"Coboundary operators are maps delta^p  C^p to C^p+1, with each linear space  C^p of p-cochains isomorphic to the space C_p of p-chain. Therefore in this package only Chain spaces are used. Notice that partial_p = delta^p^t. This property is often utilized in our algorithms.","category":"page"},{"location":"interface/#Examples-3","page":"Interface","title":"Examples","text":"","category":"section"},{"location":"interface/#","page":"Interface","title":"Interface","text":"julia> V,(VV,EV,FV,CV) = Lar.cuboid([1.,1.,1.], true);\n\njulia> EV\n12-element Array{Array{Int64,1},1}:\n [1, 2]\n [3, 4]\n   ...\n [3, 7]\n [4, 8]\n\njulia> Lar.boundary_1( EV::Lar.Cells )\n8√ó12 SparseMatrixCSC{Int8,Int64} with 24 stored entries:\n  [1 ,  1]  =  -1\n  [2 ,  1]  =  1\n  [3 ,  2]  =  -1\n\t...       ...\n  [7 , 11]  =  1\n  [4 , 12]  =  -1\n  [8 , 12]  =  1\n\njulia> Matrix(Lar.boundary_1(EV::Cells))\n8√ó12 Array{Int8,2}:\n -1   0   0   0  -1   0   0   0  -1   0   0   0\n  1   0   0   0   0  -1   0   0   0  -1   0   0\n  0  -1   0   0   1   0   0   0   0   0  -1   0\n  0   1   0   0   0   1   0   0   0   0   0  -1\n  0   0  -1   0   0   0  -1   0   1   0   0   0\n  0   0   1   0   0   0   0  -1   0   1   0   0\n  0   0   0  -1   0   0   1   0   0   0   1   0\n  0   0   0   1   0   0   0   1   0   0   0   1","category":"page"},{"location":"interface/#","page":"Interface","title":"Interface","text":"Notice that the matrix partial_1,  generated by the function boundary_1 applied to the 1-cell basis EV, contains two non-zero elements per column, where the associated edge (1-cell) is oriented from the vertex (row) of lesser index, towards the vertex of greater index, according to our numbering convention.","category":"page"},{"location":"interface/#Chain-complexes-1","page":"Interface","title":"Chain complexes","text":"","category":"section"},{"location":"interface/#","page":"Interface","title":"Interface","text":"A chain complex, for our purposes, is an algebraic structure that consists of a sequence of linear spaces  and a sequence of linear maps between consecutive linear spaces,  such that the image of each map (subspace of boundaries of p-chains) is included in the kernel (subspace of cycles of (p-1)-chains) of the next. ","category":"page"},{"location":"interface/#","page":"Interface","title":"Interface","text":"The set of all k-chains forms a group and the sequence of these groups is called a chain complex. In computing the arrangement A(S) induced by S, we actually compute the whole chain complex Cbullet generated by the cell complex X = A(S). For example, in 3D we compute all objects and arrows (morphisms) in the diagram below, and hence we obtain a computational knowledge of space subdivision homology, including the Euler number. ","category":"page"},{"location":"interface/#Examples-4","page":"Interface","title":"Examples","text":"","category":"section"},{"location":"interface/#","page":"Interface","title":"Interface","text":"From the minimal possible input, construct the whole two-dimensional chain complex, i.e. the bases for linear spaces C1 and  C2, of 1-chains and  2-chains, and the signed coboundary operators from  C0 to C1 and from C1 to C2.","category":"page"},{"location":"interface/#D-Chain-complex-1","page":"Interface","title":"2D Chain complex","text":"","category":"section"},{"location":"interface/#","page":"Interface","title":"Interface","text":"Start with the 1-skeleton (set of 1-cells) of a 2D small cuboidal grid (made of squares); in other words, suppose we only know the edges of the grid:","category":"page"},{"location":"interface/#","page":"Interface","title":"Interface","text":"julia> W = \n [0.0  0.0  0.0  0.0  1.0  1.0  1.0  1.0  2.0  2.0  2.0  2.0  3.0  3.0  3.0  3.0\n  0.0  1.0  2.0  3.0  0.0  1.0  2.0  3.0  0.0  1.0  2.0  3.0  0.0  1.0  2.0  3.0]\n# output  \n 2√ó16 Array{Float64,2}: ...\n\njulia> EW = \n[[1, 2],[2, 3],[3, 4],[5, 6],[6, 7],[7, 8],[9, 10],[10, 11],[11, 12],[13, 14],\n [14, 15],[15, 16],[1, 5],[2, 6],[3, 7],[4, 8],[5, 9],[6, 10],[7, 11],[8, 12],\n [9, 13],[10, 14],[11, 15],[12, 16]]\n# output  \n24-element Array{Array{Int64,1},1}: ...","category":"page"},{"location":"interface/#","page":"Interface","title":"Interface","text":"We go to compute the arrangement of the 2D space induced by the above, i.e. the full chain complex generated by (W,EW). This one is returned by the evaluation of the expression chaincomplex(W,EW). The output variable bases  will contain the meaningful cell bases, i.e. those of dimension 1 and 2, since dimension 0 ‚Äì isolated 0-cells ‚Äì is not so.","category":"page"},{"location":"interface/#","page":"Interface","title":"Interface","text":"julia> V,bases,coboundaries = Lar.chaincomplex(W,EW)\n\njulia> bases[1]\t# edges\n24-element Array{Array{Int64,1},1}: ...\n\njulia> bases[2] # faces -- previously unknown !!\n9-element Array{Array{Int64,1},1}: ...","category":"page"},{"location":"interface/#","page":"Interface","title":"Interface","text":"Analogously, the coboundaries variable will contain the delta_1 and delta_2 matrices, of type SparseMatrixCSC{Int8,Int64}","category":"page"},{"location":"interface/#","page":"Interface","title":"Interface","text":"julia> coboundaries[1] # coboundary_1 \n24√ó16 SparseMatrixCSC{Int8,Int64} with 48 stored entries: ...\n\njulia> Matrix(coboundaries[2]) # coboundary_1: faces as oriented 1-cycles of edges\n9√ó24 Array{Int8,2}:\n -1  0  0  1  0  0  0  0  0  0  0  0  1 -1  0  0  0  0  0  0  0  0  0  0\n  0 -1  0  0  1  0  0  0  0  0  0  0  0  1 -1  0  0  0  0  0  0  0  0  0\n  0  0 -1  0  0  1  0  0  0  0  0  0  0  0  1 -1  0  0  0  0  0  0  0  0\n  0  0  0 -1  0  0  1  0  0  0  0  0  0  0  0  0  1 -1  0  0  0  0  0  0\n  0  0  0  0 -1  0  0  1  0  0  0  0  0  0  0  0  0  1 -1  0  0  0  0  0\n  0  0  0  0  0 -1  0  0  1  0  0  0  0  0  0  0  0  0  1 -1  0  0  0  0\n  0  0  0  0  0  0  0 -1  0  0  1  0  0  0  0  0  0  0  0  0  0  1 -1  0\n  0  0  0  0  0  0 -1  0  0  1  0  0  0  0  0  0  0  0  0  0  1 -1  0  0\n  0  0  0  0  0  0  0  0 -1  0  0  1  0  0  0  0  0  0  0  0  0  0  1 -1","category":"page"},{"location":"interface/#","page":"Interface","title":"Interface","text":"Note that the last matrix contains by rows the 2-cycles corresponding to the (previously) unknown 2-basis FV that can now be easily computed. Notice also that columns corresponding to interior edges (1-cells) contain two non-zeros of opposite sign. Hence the computed 2-complex is coherently oriented by the matrix rows, actually by construction. ","category":"page"},{"location":"interface/#","page":"Interface","title":"Interface","text":"The 2-boundary operator matrix, i.e. transpose(coboundaries[2]), can be used to compute the boundary of every possible 2-chain, by matrix multiplication times the coordinate (binary) representation of the 2-chain, implemented by the type Chain, defined as SparseVector{Int8, Int}.","category":"page"},{"location":"interface/#D-Chain-complex-2","page":"Interface","title":"3D Chain complex","text":"","category":"section"},{"location":"interface/#","page":"Interface","title":"Interface","text":"The example discussed here concerns two unit cubes in 3D, where the second is rotated and translated, up to intersect only partially the firat cube. First we prepare our data, using a very simple hierarchical aggregation via a Struct object, to get a representation of faces and edges of both cubes in two Cells arrays FV and EV.","category":"page"},{"location":"interface/#","page":"Interface","title":"Interface","text":"julia> cube_1 = ([0 0 0 0 1 1 1 1; 0 0 1 1 0 0 1 1; 0 1 0 1 0 1 0 1], \n[[1,2,3,4],[5,6,7,8],[1,2,5,6],[3,4,7,8],[1,3,5,7],[2,4,6,8]], \n[[1,2],[3,4],[5,6],[7,8],[1,3],[2,4],[5,7],[6,8],[1,5],[2,6],[3,7],[4,8]] )\n\njulia> cube_2 = Lar.Struct([Lar.t(0,0,0.5), Lar.r(0,0,pi/3), cube_1])\n\njulia> V,FV,EV = Lar.struct2lar(Lar.Struct([ cube_1, cube_2 ]))","category":"page"},{"location":"interface/#","page":"Interface","title":"Interface","text":"Then we compute the 3D space arrangement induced by FV, providing the auxiliary information in EV, and getting back V,bases,coboundaries. Both bases and coboundaries are then disassembled into their component data structures. The actual discoveries computed by the arrangement algorithms, called by the chaincomplex function, are the NEW EV, FV, CV basis and the cscEV, cscFE, cscCF operators, which stands  for delta_0,delta_1, anddelta_2, i.e. the computations of the solid 3D cells generated by the arrangement of space, including their full topology.","category":"page"},{"location":"interface/#","page":"Interface","title":"Interface","text":"julia> V,bases,coboundaries = Lar.chaincomplex(V,FV,EV)\n\njulia> (EV, FV, CV), (cscEV, cscFE, cscCF) = bases,coboundaries\n\njulia> FV # bases[2]\n18-element Array{Array{Int64,1},1}:\n [1, 3, 4, 6]            \n [2, 3, 5, 6]            \n [7, 8, 9, 10]           \n [1, 2, 3, 7, 8]         \n [4, 6, 9, 10, 11, 12]   \n [5, 6, 11, 12]          \n [1, 4, 7, 9]            \n [2, 5, 11, 13]          \n [2, 8, 10, 11, 13]      \n [2, 3, 14, 15, 16]      \n [11, 12, 13, 17]        \n [11, 12, 13, 18, 19, 20]\n [2, 3, 13, 17]          \n [2, 13, 14, 18]         \n [15, 16, 19, 20]        \n [3, 6, 12, 15, 19]      \n [3, 6, 12, 17]          \n [14, 16, 18, 20]        \n\njulia> CV # bases[3]\n3-element Array{Array{Int64,1},1}:\n [2, 3, 5, 6, 11, 12, 13, 14, 15, 16, 18, 19, 20]\n [2, 3, 5, 6, 11, 12, 13, 17]                    \n [1, 2, 3, 4, 6, 7, 8, 9, 10, 11, 12, 13, 17]    ","category":"page"},{"location":"interface/#","page":"Interface","title":"Interface","text":"Let note that the LAR of FV includes faces with 5 and 6 vertices, even non convex.  Also, the CV variable contains the LAR of the three solid parts the two cubes are split into. ","category":"page"},{"location":"interface/#","page":"Interface","title":"Interface","text":"julia> cscEV # coboundaries[1]\n34√ó20 SparseMatrixCSC{Int8,Int64} with 68 stored entries: ...\n\njulia> cscFE # coboundaries[2]\n18√ó34 SparseMatrixCSC{Int8,Int64} with 80 stored entries: ...\n\njulia> cscCF # coboundaries[3]\n4√ó18 SparseMatrixCSC{Int8,Int64} with 36 stored entries: ...","category":"page"},{"location":"interface/#Main-Interface-1","page":"Interface","title":"Main Interface","text":"","category":"section"},{"location":"interface/#","page":"Interface","title":"Interface","text":"Lar.characteristicMatrix","category":"page"},{"location":"interface/#LinearAlgebraicRepresentation.characteristicMatrix","page":"Interface","title":"LinearAlgebraicRepresentation.characteristicMatrix","text":"characteristicMatrix( FV::Cells )::ChainOp\n\nBinary matrix representing by rows the p-cells of a cellular complex. The input parameter must be of Cells type. Return a sparse binary matrix,  providing the basis of a Chain space of given dimension. Notice that the  number of columns is equal to the number of vertices (0-cells). \n\nExample\n\nV,(VV,EV,FV,CV) = cuboid([1.,1.,1.], true); \n\njulia> Matrix(characteristicMatrix(FV))\n6√ó8 Array{Int8,2}:\n1  1  1  1  0  0  0  0\n0  0  0  0  1  1  1  1\n1  1  0  0  1  1  0  0\n0  0  1  1  0  0  1  1\n1  0  1  0  1  0  1  0\n0  1  0  1  0  1  0  1\n\njulia> Matrix(characteristicMatrix(CV))\n1√ó8 Array{Int8,2}:\n1  1  1  1  1  1  1  1\n\njulia> Matrix(characteristicMatrix(EV))\n12√ó8 Array{Int8,2}:\n1  1  0  0  0  0  0  0\n0  0  1  1  0  0  0  0\n0  0  0  0  1  1  0  0\n0  0  0  0  0  0  1  1\n1  0  1  0  0  0  0  0\n0  1  0  1  0  0  0  0\n0  0  0  0  1  0  1  0\n0  0  0  0  0  1  0  1\n1  0  0  0  1  0  0  0\n0  1  0  0  0  1  0  0\n0  0  1  0  0  0  1  0\n0  0  0  1  0  0  0  1\n\n\n\n\n\n","category":"function"},{"location":"interface/#","page":"Interface","title":"Interface","text":"Lar.boundary_1","category":"page"},{"location":"interface/#LinearAlgebraicRepresentation.boundary_1","page":"Interface","title":"LinearAlgebraicRepresentation.boundary_1","text":"boundary_1( EV::Cells )::ChainOp\n\nComputation of sparse signed boundary operator C_1 - C_0.\n\nExample\n\njulia> V,(VV,EV,FV,CV) = cuboid([1.,1.,1.], true);\n\njulia> EV\n12-element Array{Array{Int64,1},1}:\n[1, 2]\n[3, 4]\n...\n[2, 6]\n[3, 7]\n[4, 8]\n\njulia> boundary_1( EV::Cells )\n8√ó12 SparseMatrixCSC{Int8,Int64} with 24 stored entries:\n[1 ,  1]  =  -1\n[2 ,  1]  =  1\n[3 ,  2]  =  -1\n...       ...\n[7 , 11]  =  1\n[4 , 12]  =  -1\n[8 , 12]  =  1\n\njulia> Matrix(boundary_1(EV::Cells))\n8√ó12 Array{Int8,2}:\n-1   0   0   0  -1   0   0   0  -1   0   0   0\n1   0   0   0   0  -1   0   0   0  -1   0   0\n0  -1   0   0   1   0   0   0   0   0  -1   0\n0   1   0   0   0   1   0   0   0   0   0  -1\n0   0  -1   0   0   0  -1   0   1   0   0   0\n0   0   1   0   0   0   0  -1   0   1   0   0\n0   0   0  -1   0   0   1   0   0   0   1   0\n0   0   0   1   0   0   0   1   0   0   0   1\n\n\n\n\n\n","category":"function"},{"location":"interface/#","page":"Interface","title":"Interface","text":"Lar.coboundary_0","category":"page"},{"location":"interface/#LinearAlgebraicRepresentation.coboundary_0","page":"Interface","title":"LinearAlgebraicRepresentation.coboundary_0","text":"coboundary_0(EV::Lar.Cells)\n\nReturn the coboundary_0 signed operator C_0 -> C_1.\n\n\n\n\n\n","category":"function"},{"location":"interface/#","page":"Interface","title":"Interface","text":"Lar.u_coboundary_1","category":"page"},{"location":"interface/#LinearAlgebraicRepresentation.u_coboundary_1","page":"Interface","title":"LinearAlgebraicRepresentation.u_coboundary_1","text":"u_coboundary_1( FV::Lar.Cells, EV::Lar.Cells, convex=true)::Lar.ChainOp\n\nCompute the sparse unsigned coboundary1 operator ``C1 -> C_2`. Notice that the output matrix ism x n, wheremis the number of faces, andn`  is the number of edges.\n\nExamples\n\nCellular complex with convex-cells, and without outer cell\n\njulia> V,(VV,EV,FV,CV) = Lar.cuboid([1.,1.,1.], true);\n\njulia> u_coboundary_1(FV,EV)\n6√ó12 SparseMatrixCSC{Int8,Int64} with 24 stored entries:\n[1 ,  1]  =  1\n[3 ,  1]  =  1\n[1 ,  2]  =  1\n[4 ,  2]  =  1\n...\t\t...\n[4 , 11]  =  1\n[5 , 11]  =  1\n[4 , 12]  =  1\n[6 , 12]  =  1\n\njulia> Matrix(u_coboundary_1(FV,EV))\n6√ó12 Array{Int8,2}:\n1  1  0  0  1  1  0  0  0  0  0  0\n0  0  1  1  0  0  1  1  0  0  0  0\n1  0  1  0  0  0  0  0  1  1  0  0\n0  1  0  1  0  0  0  0  0  0  1  1\n0  0  0  0  1  0  1  0  1  0  1  0\n0  0  0  0  0  1  0  1  0  1  0  1\n\njulia> unsigned_boundary_2 = u_coboundary_1(FV,EV)';\n\nCompute the Unsigned coboundary_1 operator matrix as product of two sparse characteristic matrices.\n\nCellular complex with non-convex cells, and with outer cell\n\nFV = [[1,2,3,4,5,17,16,12], # outer cell\n[1,2,3,4,6,7,8,9,10,11,12,13,14,15],\n[4,5,9,11,12,13,14,15,16,17],\n[2,3,6,7], [8,9,10,11]]\n\nEV = [[1,2],[2,3],[3,4],[4,5],[1,12],[2,6],[3,7],[4,9],[5,17],[6,7],[8,9],\n[8,10],[9,11],[10,11],[11,15],[12,13],[12,16],[13,14],[14,15],[16,17]]\n\nout = u_coboundary_1( FV::Lar.Cells, EV::Lar.Cells, false)\n\nIn case of expected 2-chains with non-convex cells, instance the method with  convex = false, in order to fix a possible redundancy of incidence values, induced by computation through multiplication of characteristic matrices. (Look at columns  2 and 13 before, generated by default).\n\n\n\n\n\n","category":"function"},{"location":"interface/#","page":"Interface","title":"Interface","text":"Lar.u_boundary_2","category":"page"},{"location":"interface/#LinearAlgebraicRepresentation.u_boundary_2","page":"Interface","title":"LinearAlgebraicRepresentation.u_boundary_2","text":"u_boundary_2(FV::Lar.Cells, EV::Lar.Cells)::Lar.ChainOp\n\nReturn the unsigned boundary_2 operator C_2 -> C_1.\n\n\n\n\n\n","category":"function"},{"location":"interface/#","page":"Interface","title":"Interface","text":"Lar.coboundary_1","category":"page"},{"location":"interface/#LinearAlgebraicRepresentation.coboundary_1","page":"Interface","title":"LinearAlgebraicRepresentation.coboundary_1","text":"coboundary_1( FV::Lar.Cells, EV::Lar.Cells)::Lar.ChainOp\n\nGenerate the signed sparse matrix of the coboundary_1 operator. For each row, start with the first incidence number positive (i.e. assign the orientation of the first edge to the 1-cycle of the face), then bounce back and forth between vertex columns/rows of EV and FE.\n\nExample\n\njulia> Matrix(cscFE) 5√ó20 Array{Int8,2}:  1  1  1  1  1  0  0  0  1  0  0  0  0  0  0  0  1  0  0  1  1  0  1  0  1  1  1  1  0  1  1  1  0  1  1  1  0  1  1  0  0  0  0  1  0  0  0  1  1  0  0  0  1  0  1  1  1  1  1  1  0  1  0  0  0  1  1  0  0  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  1  1  1  1  0  0  0  0  0  0\n\n\n\n\n\n","category":"function"},{"location":"interface/#","page":"Interface","title":"Interface","text":"Lar.chaincomplex","category":"page"},{"location":"interface/#LinearAlgebraicRepresentation.chaincomplex","page":"Interface","title":"LinearAlgebraicRepresentation.chaincomplex","text":"chaincomplex( W::Points, EW::Cells )::Tuple{Array{Cells,1},Array{ChainOp,1}}\n\nChain 2-complex construction from basis of 1-cells. \n\nFrom the minimal input, construct the whole two-dimensional chain complex, i.e. the bases for linear spaces C1 and  C2 of 1-chains and  2-chains, and the signed coboundary operators from  C0 to C1 and from C1 to C2.\n\nExample\n\njulia> W = \n[0.0  0.0  0.0  0.0  1.0  1.0  1.0  1.0  2.0  2.0  2.0  2.0  3.0  3.0  3.0  3.0\n0.0  1.0  2.0  3.0  0.0  1.0  2.0  3.0  0.0  1.0  2.0  3.0  0.0  1.0  2.0  3.0]\n# output  \n2√ó16 Array{Float64,2}: ...\n\njulia> EW = \n[[1, 2],[2, 3],[3, 4],[5, 6],[6, 7],[7, 8],[9, 10],[10, 11],[11, 12],[13, 14],\n[14, 15],[15, 16],[1, 5],[2, 6],[3, 7],[4, 8],[5, 9],[6, 10],[7, 11],[8, 12],\n[9, 13],[10, 14],[11, 15],[12, 16]]\n# output  \n24-element Array{Array{Int64,1},1}: ...\n\njulia> V,bases,coboundaries = chaincomplex(W,EW)\n\njulia> bases[1]\t# edges\n24-element Array{Array{Int64,1},1}: ...\n\njulia> bases[2] # faces -- previously unknown !!\n9-element Array{Array{Int64,1},1}: ...\n\njulia> coboundaries[1] # coboundary_1 \n24√ó16 SparseMatrixCSC{Int8,Int64} with 48 stored entries: ...\n\njulia> Matrix(coboundaries[2]) # coboundary_1: faces as oriented 1-cycles of edges\n9√ó24 Array{Int8,2}:\n-1  0  0  1  0  0  0  0  0  0  0  0  1 -1  0  0  0  0  0  0  0  0  0  0\n0 -1  0  0  1  0  0  0  0  0  0  0  0  1 -1  0  0  0  0  0  0  0  0  0\n0  0 -1  0  0  1  0  0  0  0  0  0  0  0  1 -1  0  0  0  0  0  0  0  0\n0  0  0 -1  0  0  1  0  0  0  0  0  0  0  0  0  1 -1  0  0  0  0  0  0\n0  0  0  0 -1  0  0  1  0  0  0  0  0  0  0  0  0  1 -1  0  0  0  0  0\n0  0  0  0  0 -1  0  0  1  0  0  0  0  0  0  0  0  0  1 -1  0  0  0  0\n0  0  0  0  0  0  0 -1  0  0  1  0  0  0  0  0  0  0  0  0  0  1 -1  0\n0  0  0  0  0  0 -1  0  0  1  0  0  0  0  0  0  0  0  0  0  1 -1  0  0\n0  0  0  0  0  0  0  0 -1  0  0  1  0  0  0  0  0  0  0  0  0  0  1 -1\n\n\n\n\n\nchaincomplex( W::Points, FW::Cells, EW::Cells )\n\t::Tuple{ Array{Cells,1}, Array{ChainOp,1} }\n\nChain 3-complex construction from bases of 2- and 1-cells. \n\nFrom the minimal input, construct the whole two-dimensional chain complex, i.e. the bases for linear spaces C1 and  C2 of 1-chains and  2-chains, and the signed coboundary operators from  C0 to C1  and from C1 to C2.\n\nExample\n\njulia> cube_1 = ([0 0 0 0 1 1 1 1; 0 0 1 1 0 0 1 1; 0 1 0 1 0 1 0 1], \n[[1,2,3,4],[5,6,7,8],[1,2,5,6],[3,4,7,8],[1,3,5,7],[2,4,6,8]], \n[[1,2],[3,4],[5,6],[7,8],[1,3],[2,4],[5,7],[6,8],[1,5],[2,6],[3,7],[4,8]] )\n\njulia> cube_2 = Lar.Struct([Lar.t(0,0,0.5), Lar.r(0,0,pi/3), cube_1])\n\njulia> V,FV,EV = Lar.struct2lar(Lar.Struct([ cube_1, cube_2 ]))\n\njulia> V,bases,coboundaries = Lar.chaincomplex(V,FV,EV)\n\njulia> (EV, FV, CV), (cscEV, cscFE, cscCF) = bases,coboundaries\n\njulia> FV # bases[2]\n18-element Array{Array{Int64,1},1}:\n[1, 3, 4, 6]            \n[2, 3, 5, 6]            \n[7, 8, 9, 10]           \n[1, 2, 3, 7, 8]         \n[4, 6, 9, 10, 11, 12]   \n[5, 6, 11, 12]          \n[1, 4, 7, 9]            \n[2, 5, 11, 13]          \n[2, 8, 10, 11, 13]      \n[2, 3, 14, 15, 16]      \n[11, 12, 13, 17]        \n[11, 12, 13, 18, 19, 20]\n[2, 3, 13, 17]          \n[2, 13, 14, 18]         \n[15, 16, 19, 20]        \n[3, 6, 12, 15, 19]      \n[3, 6, 12, 17]          \n[14, 16, 18, 20]        \n\njulia> CV # bases[3]\n3-element Array{Array{Int64,1},1}:\n[2, 3, 5, 6, 11, 12, 13, 14, 15, 16, 18, 19, 20]\n[2, 3, 5, 6, 11, 12, 13, 17]                    \n[1, 2, 3, 4, 6, 7, 8, 9, 10, 11, 12, 13, 17]    \n\njulia> cscEV # coboundaries[1]\n34√ó20 SparseMatrixCSC{Int8,Int64} with 68 stored entries: ...\n\njulia> cscFE # coboundaries[2]\n18√ó34 SparseMatrixCSC{Int8,Int64} with 80 stored entries: ...\n\njulia> cscCF # coboundaries[3]\n4√ó18 SparseMatrixCSC{Int8,Int64} with 36 stored entries: ...\n\n\n\n\n\n","category":"function"},{"location":"arrangement/#Arrangement-of-cellular-complexes-1","page":"Arrangement","title":"Arrangement of cellular complexes","text":"","category":"section"},{"location":"arrangement/#","page":"Arrangement","title":"Arrangement","text":"The arrangement is an algorithm which gets two general d-dimensional cellular complexes and arranges them in a singular d-dimensional cellular complex of which the cells respect the conditions:","category":"page"},{"location":"arrangement/#","page":"Arrangement","title":"Arrangement","text":"sigma_1 cap sigma_2 = emptysetquad forall couple of cells (sigma_1 sigma_2)\nbigcup_isigma_i = mathbbE^d","category":"page"},{"location":"arrangement/#","page":"Arrangement","title":"Arrangement","text":"This operation can be seen as a boolean union of two cellular complexes. Here an exploded visualization of the final result of the arrangement algorithm ran on 2 cubes made by 10times10times10 smaller cubes.","category":"page"},{"location":"arrangement/#","page":"Arrangement","title":"Arrangement","text":"(Image: 10 x 10 Cube)","category":"page"},{"location":"arrangement/#","page":"Arrangement","title":"Arrangement","text":"Figure 1: Arrangement of 2000=2times10times10times10 cubes","category":"page"},{"location":"arrangement/#Graph-of-recall-functions-1","page":"Arrangement","title":"Graph of recall functions","text":"","category":"section"},{"location":"arrangement/#","page":"Arrangement","title":"Arrangement","text":"A graph is an ordered pair G(VE) comprising a set V of vertices, nodes or points together with a set E of edges, arcs or lines, which are 2-elements subsets of V. In this case, V is the set of functions of this sub-module and let v1, v2 be elements of V, then e=v1v2 in E if v1 calls v2. In the following graph the functions are arranged in colored boxes: (Image: dependency graph)","category":"page"},{"location":"arrangement/#","page":"Arrangement","title":"Arrangement","text":"yellow boxes is for spatial_arrangement\nred boxes is for planar_arrangement\ngreen boxes is for minimal_cycles\nblue boxes is for dimension_travel","category":"page"},{"location":"arrangement/#","page":"Arrangement","title":"Arrangement","text":"Functions in darker boxes are declared only in the local scope of its father.","category":"page"},{"location":"arrangement/#API-1","page":"Arrangement","title":"API","text":"","category":"section"},{"location":"arrangement/#","page":"Arrangement","title":"Arrangement","text":"Every functions strictly relative to the arrangement has been collected in the Lar.Arrangement sub-module but the two main functions are accessible directly from the LinearAlgebraicRepresentation namespace.","category":"page"},{"location":"arrangement/#","page":"Arrangement","title":"Arrangement","text":"warning: Warning\nLar.Arrangement is the only place in LinearAlgebraicRepresentation where Point matrices store points per row and not per column as described in the documentation of Lar.Points","category":"page"},{"location":"arrangement/#","page":"Arrangement","title":"Arrangement","text":"Lar.spatial_arrangement\nLar.planar_arrangement","category":"page"},{"location":"arrangement/#LinearAlgebraicRepresentation.spatial_arrangement","page":"Arrangement","title":"LinearAlgebraicRepresentation.spatial_arrangement","text":"spatial_arrangement(V::Points, copEV::ChainOp, copFE::ChainOp; [multiproc::Bool])\n\nCompute the arrangement on the given cellular complex 2-skeleton in 3D.\n\nA cellular complex is arranged when the intersection of every possible pair of cell  of the complex is empty and the union of all the cells is the whole Euclidean space. The function returns the full arranged complex as a list of vertices V and a chain of borders EV, FE, CF.\n\nAdditional arguments:\n\nmultiproc::Bool: Runs the computation in parallel mode. Defaults to false.\n\n\n\n\n\n","category":"function"},{"location":"arrangement/#LinearAlgebraicRepresentation.planar_arrangement","page":"Arrangement","title":"LinearAlgebraicRepresentation.planar_arrangement","text":"planar_arrangement(V::Points, copEV::ChainOp, \n\t[sigma::Chain], [return_edge_map::Bool], [multiproc::Bool])\n\nCompute the arrangement on the given cellular complex 1-skeleton in 2D. Whole arrangement's algorithmic pipeline. \n\nA cellular complex is arranged when the intersection of every possible pair of cell  of the complex is empty and the union of all the cells is the whole Euclidean space. The basic method of the function without the sigma, return_edge_map and multiproc arguments  returns the full arranged complex V, EV and FE.\n\nAdditional arguments:\n\nsigma::Chain: if specified, planar_arrangement will delete from the output every edge and face outside this cell. Defaults to an empty cell.\nreturn_edge_map::Bool: makes the function return also an edge_map which maps the edges of the imput to the one of the output. Defaults to false.\nmultiproc::Bool: Runs the computation in parallel mode. Defaults to false.\n\n\n\n\n\n","category":"function"},{"location":"arrangement/#","page":"Arrangement","title":"Arrangement","text":"note: Note\nEven if the arrangement algorithm is theoretically dimension independent, we implemented \"only\" the d=2 and d=3 version of it.","category":"page"},{"location":"arrangement/#Theoretical-basis-1","page":"Arrangement","title":"Theoretical basis","text":"","category":"section"},{"location":"arrangement/#","page":"Arrangement","title":"Arrangement","text":"The algorithm is based on the concept of recursive problem simplification  (a sort of divide et impera philosophy); if we have a d-complex, for every (d-1)-cell embedded into the mathbbE^d euclidean space, we bring the cell, and every other cell that could intersect it, down into mathbbE^d-1. We do this until we reach the d=1 in mathbbE^1 case; in here, we fragment all the 1-cells. Then, we travel back to the original d-dimension, and, for each dimensional step, we build correct complexes from cells provided by the  fragmentation of the lower dimension. ","category":"page"},{"location":"arrangement/#","page":"Arrangement","title":"Arrangement","text":"(Image: Arrangement steps)","category":"page"},{"location":"arrangement/#","page":"Arrangement","title":"Arrangement","text":"Figure 2: Algorithm overview","category":"page"},{"location":"arrangement/#","page":"Arrangement","title":"Arrangement","text":"We have in input two cellular complexes [fig. 2, a],  given as 2-skeletons, which are the sets of 2-cells  [fig. 2, b, exploded]. Once we merged the skeletons,  we individuate for each 2-cell (that we will call sigma) all the other cells that could intersect it. We do this by computing the spatial index: it is a mapping mathcalI(sigma) from a cell  sigma to every other cell tau of which box(sigma) cap box(tau) neq emptyset, where the box function provides the axis aligned bounding box (AABB) of a cell [fig. 2, c,  sigma in red and mathcalI(sigma) in blue]. The spatial arrangement calculation is speeded up by storing the AABBs as dimensional wise intervals into an interval tree citeinterval_trees.  Now for each cell sigma we transform sigma cup mathcalI(sigma)  in a way that sigma lays on the x_3=0  plane [fig. 2, d] and we find the intersections  of the mathcalI(sigma) cells with x_3=0  plane. So we have a \"soup\" of 1-cells in mathbbE^2 [fig. 2, e], and we fragment each 1-cell  with every other cell obtaining a valid 1-skeleton [fig. 2, f]. From this data it is possible to build the 2-cells using the ALGORITHM 1 presented and explored by Paoluzzi et al. citePaoluzzi [fig. 2, g, exploded]. The procedure to fragment 1-cells on a plane and return a 2-complex is called planar arrangement. When the planar arrangement  is complete, fragmented sigma can be transformed back to its original position in mathbbE^3. With every 2-cell correctly fragmented, we can use the  already cited ALGORITHM 1 again to build a full 3-complex [fig. 2, h, exploded]. This is possible because ALGORITHM 1 is (almost) dimension independent.","category":"page"},{"location":"arrangement/#The-\"1-cells-in-\\mathbb{E}2\"-base-case-1","page":"Arrangement","title":"The \"1-cells in mathbbE^2\" base case","text":"","category":"section"},{"location":"arrangement/#","page":"Arrangement","title":"Arrangement","text":"(Image: Planar arrangement overview)","category":"page"},{"location":"arrangement/#","page":"Arrangement","title":"Arrangement","text":"Figure 3: Planar arrangement overview","category":"page"},{"location":"arrangement/#","page":"Arrangement","title":"Arrangement","text":"This is our base case. We have called planar arrangement the procedure to handle this case since it literally arranges a bunch of edges laying on a plane. So, in input there are 1-cells in mathbbE^2 and, optionally (but very likely), the boundary of the original 2-cell sigma  [fig. 3, a, sigma in red]. We consider each edge and we fragment it with every other edge. This brings to the creation of several coincident vertices: these will be eliminated using a KD-Tree [fig. 3, b, exploded].  At this point we have a perfectly fragmented 1-complex but many edges are superfluous and must be eliminated; two kind of edges are to discard: the ones outside the area of sigma and the ones which are not part of a maximal biconnected component  (We can talk about biconnected components because we can consider the 1-skeleton as a graph:  0-cells are nodes, 1-cells are edges and the boundary operator is a incidence matrix.). The result of this edge pruning outputs a 1-skeleton [fig. 3, c, exploded].","category":"page"},{"location":"arrangement/#","page":"Arrangement","title":"Arrangement","text":"After this, 2-cells must be computed: For each connected component we build a containment tree, which indicates which component is spatially inside an other component. Computing these relations lets us launch the ALGORITHM 1 \\cite{Paoluzzi} on each component and then combine the results to create 2-cells with non-intersecting  shells [fig. 3, d, 2-cells numbered in green; please note that cell 2 has cell 1 as an hole].","category":"page"},{"location":"arrangement/#","page":"Arrangement","title":"Arrangement","text":"note: Note\nA 2-cell with a non-intersecting shell can be trivially defined as a \"face with holes\"; the correct definition is that it cannot  be shrunk to the dimension of a point.","category":"page"},{"location":"arrangement/#Main-Interface-1","page":"Arrangement","title":"Main Interface","text":"","category":"section"},{"location":"arrangement/#Dimension-travel-1","page":"Arrangement","title":"Dimension travel","text":"","category":"section"},{"location":"arrangement/#Minimal-cycles-1","page":"Arrangement","title":"Minimal cycles","text":"","category":"section"},{"location":"arrangement/#","page":"Arrangement","title":"Arrangement","text":"Lar.Arrangement.minimal_2cycles","category":"page"},{"location":"arrangement/#LinearAlgebraicRepresentation.Arrangement.minimal_2cycles","page":"Arrangement","title":"LinearAlgebraicRepresentation.Arrangement.minimal_2cycles","text":"minimal_2cycles(V::Lar.Points, EV::Lar.ChainOp)\n\nReturn all cycles of a 2D graph define by its vertices and edges.\n\n\n\n\n\n","category":"function"},{"location":"arrangement/#","page":"Arrangement","title":"Arrangement","text":"Lar.Arrangement.minimal_3cycles","category":"page"},{"location":"arrangement/#LinearAlgebraicRepresentation.Arrangement.minimal_3cycles","page":"Arrangement","title":"LinearAlgebraicRepresentation.Arrangement.minimal_3cycles","text":"minimal_3cycles(V::Lar.Points, EV::Lar.ChainOp, FE::Lar.ChainOp)\n\n\n\n\n\n","category":"function"},{"location":"arrangement/#Planar-arrangement-1","page":"Arrangement","title":"Planar arrangement","text":"","category":"section"},{"location":"arrangement/#","page":"Arrangement","title":"Arrangement","text":"Lar.Arrangement.intersect_edges","category":"page"},{"location":"arrangement/#LinearAlgebraicRepresentation.Arrangement.intersect_edges","page":"Arrangement","title":"LinearAlgebraicRepresentation.Arrangement.intersect_edges","text":"intersect_edges(V::Lar.Points, edge1::Lar.Cell, edge2::Lar.Cell)\n\nIntersection of two edges. Return, if exist, points of intersection and parameter.\n\nExample\n\njulia> V=[0 0 ; 1 1; 1/2 0; 1/2 1];\n\njulia> EV = SparseArrays.sparse(Array{Int8, 2}([\n                            [1 1 0 0] #1->1,2\n                            [0 0 1 1] #2->3,4       \n                        ]));\n\njulia> Lar.Arrangement.intersect_edges(V, EV[1, :], EV[2, :])\n1-element Array{Tuple{Array{T,2} where T,Float64},1}:\n ([0.5 0.5], 0.5)\n\n\n\n\n\n\n","category":"function"},{"location":"arrangement/#","page":"Arrangement","title":"Arrangement","text":"Lar.Arrangement.frag_edge","category":"page"},{"location":"arrangement/#LinearAlgebraicRepresentation.Arrangement.frag_edge","page":"Arrangement","title":"LinearAlgebraicRepresentation.Arrangement.frag_edge","text":"frag_edge(V::Lar.Points, EV::Lar.ChainOp, edge_idx::Int, bigPI)\n\nReturn vertices and edges after intersection.\n\nExample\n\njulia> V = [ 0 0; 1 1; 1 0; 0 1];\n\njulia> EV = Int8[ 1 1 0 0;\n                  0 0 1 1; \n                  ];\n\njulia> EV = sparse(EV);\n\njulia> model = (convert(Lar.Points,V'),Lar.cop2lar(EV));\n\njulia> bigPI = Lar.spaceindex(model::Lar.LAR);\n\njulia> Lar.Arrangement.frag_edge(V, EV, 1, bigPI)\n([0.0 0.0; 1.0 1.0; 0.5 0.5], \n  [1, 1]  =  1\n  [2, 2]  =  1\n  [1, 3]  =  1\n  [2, 3]  =  1)\n\njulia> Lar.Arrangement.frag_edge(V, EV, 2, bigPI)\n([1.0 0.0; 0.0 1.0; 0.5 0.5], \n  [1, 1]  =  1\n  [2, 2]  =  1\n  [1, 3]  =  1\n  [2, 3]  =  1)\n\n\n\n\n\n\n\n","category":"function"},{"location":"arrangement/#","page":"Arrangement","title":"Arrangement","text":"Lar.Arrangement.merge_vertices!","category":"page"},{"location":"arrangement/#LinearAlgebraicRepresentation.Arrangement.merge_vertices!","page":"Arrangement","title":"LinearAlgebraicRepresentation.Arrangement.merge_vertices!","text":"merge_vertices!(V::Lar.Points, EV::Lar.ChainOp, edge_map, err=1e-4)\n\nIf two or more vertices are very close, return one vertex and right edges. \n\nExample\n\njulia> p0 = 1e-2;\n\njulia> pm = 1-p0;\n\njulia> pp = 1+p0;\n\njulia> V = [ p0  p0; p0 -p0;\n                    pp pm; pp pp\n                  ];\n\njulia> EV = Int8[1 0 1 0 ;\n                 0 1 0 1 ;\n                 1 0 0 1 ;\n                 0 1 1 0 ];\n\njulia> EV = sparse(EV);\n\njulia> Lar.Arrangement.merge_vertices!(V, EV, [],1e-1)\n([0.01 0.01; 1.01 0.99], \n  [1, 1]  =  1\n  [1, 2]  =  1)\n\n\n\n\n\n","category":"function"},{"location":"arrangement/#","page":"Arrangement","title":"Arrangement","text":"Lar.Arrangement.biconnected_components","category":"page"},{"location":"arrangement/#LinearAlgebraicRepresentation.Arrangement.biconnected_components","page":"Arrangement","title":"LinearAlgebraicRepresentation.Arrangement.biconnected_components","text":"biconnected_components(EV::Lar.ChainOp)\n\nFind the biconnected components of a graph define by his edges. A biconnected component is a maximal biconnected subgraph. A biconnected graph has no articulation vertices. \n\nExample\n\njulia> EV = Int8[1 1 0 0 0 0;\n               0 1 1 0 0 0;\n               1 0 1 0 0 0;\n               1 0 0 0 1 0;\n               0 0 0 1 1 0;\n               0 0 0 1 0 1;\n               0 0 0 0 1 1] ;\n\njulia> EV = sparse(EV);\n\njulia> bc = Lar.Arrangement.biconnected_components(EV)\n2-element Array{Array{Int64,1},1}:\n [3, 2, 1]\n [7, 6, 5]\n\n\n\n\n\n","category":"function"},{"location":"arrangement/#","page":"Arrangement","title":"Arrangement","text":"Lar.Arrangement.get_external_cycle","category":"page"},{"location":"arrangement/#LinearAlgebraicRepresentation.Arrangement.get_external_cycle","page":"Arrangement","title":"LinearAlgebraicRepresentation.Arrangement.get_external_cycle","text":"get_external_cycle(V::Lar.Points, EV::Lar.ChainOp, FE::Lar.ChainOp)\n\nGet the face's index of external cell in FE. \n\n\n\n\n\n","category":"function"},{"location":"arrangement/#","page":"Arrangement","title":"Arrangement","text":"Lar.Arrangement.pre_containment_test","category":"page"},{"location":"arrangement/#LinearAlgebraicRepresentation.Arrangement.pre_containment_test","page":"Arrangement","title":"LinearAlgebraicRepresentation.Arrangement.pre_containment_test","text":"pre_containment_test(bboxes)\n\nReturn containment graph. An element (i,j) is 1 if the i-th cell is contained in the boundary box of the j-th cell.\n\n\n\n\n\n","category":"function"},{"location":"arrangement/#","page":"Arrangement","title":"Arrangement","text":"Lar.Arrangement.prune_containment_graph","category":"page"},{"location":"arrangement/#LinearAlgebraicRepresentation.Arrangement.prune_containment_graph","page":"Arrangement","title":"LinearAlgebraicRepresentation.Arrangement.prune_containment_graph","text":"prune_containment_graph(n, V, EVs, shells, graph)\n\nCheck if the origin point of a cell is inside the face area of other cell in the graph.   \n\n\n\n\n\n","category":"function"},{"location":"arrangement/#","page":"Arrangement","title":"Arrangement","text":"Lar.Arrangement.transitive_reduction!","category":"page"},{"location":"arrangement/#LinearAlgebraicRepresentation.Arrangement.transitive_reduction!","page":"Arrangement","title":"LinearAlgebraicRepresentation.Arrangement.transitive_reduction!","text":"transitive_reduction!(graph)\n\nRemove elements from containment graph that can be compute for transitivity.\n\nExample\n\njulia> graph = [0 1 1 1 ; 0 0 1 1 ; 0 0 0 1 ; 0 0 0 0 ];\n\njulia> Lar.Arrangement.transitive_reduction!(graph)\n\njulia> graph\n4√ó4 Array{Int64,2}:\n 0  1  0  0\n 0  0  1  0\n 0  0  0  1\n 0  0  0  0\n\n\n\n\n\n\n","category":"function"},{"location":"arrangement/#","page":"Arrangement","title":"Arrangement","text":"Lar.Arrangement.componentgraph","category":"page"},{"location":"arrangement/#LinearAlgebraicRepresentation.Arrangement.componentgraph","page":"Arrangement","title":"LinearAlgebraicRepresentation.Arrangement.componentgraph","text":"componentgraph(V, copEV, bicon_comps)\n\nReturn some properties of a graph, in order: n, containment_graph, V, EVs, boundaries, shells, shell_bboxes. \n\n\n\n\n\n","category":"function"},{"location":"arrangement/#","page":"Arrangement","title":"Arrangement","text":"Lar.Arrangement.cell_merging","category":"page"},{"location":"arrangement/#LinearAlgebraicRepresentation.Arrangement.cell_merging","page":"Arrangement","title":"LinearAlgebraicRepresentation.Arrangement.cell_merging","text":"cell_merging(n, containment_graph, V, EVs, boundaries, shells, shell_bboxes)\n\nMerge all cells.\n\n\n\n\n\n","category":"function"},{"location":"arrangement/#","page":"Arrangement","title":"Arrangement","text":"Lar.Arrangement.cleandecomposition","category":"page"},{"location":"arrangement/#LinearAlgebraicRepresentation.Arrangement.cleandecomposition","page":"Arrangement","title":"LinearAlgebraicRepresentation.Arrangement.cleandecomposition","text":"cleandecomposition(V, copEV, sigma)\n\nDelete edges outside sigma area.\n\n\n\n\n\n","category":"function"},{"location":"arrangement/#","page":"Arrangement","title":"Arrangement","text":"Lar.Arrangement.planar_arrangement_1","category":"page"},{"location":"arrangement/#LinearAlgebraicRepresentation.Arrangement.planar_arrangement_1","page":"Arrangement","title":"LinearAlgebraicRepresentation.Arrangement.planar_arrangement_1","text":"function planar_arrangement_1( V::Lar.Points, copEV::Lar.ChainOp, \n\tsigma::Lar.Chain=spzeros(Int8, 0), \n\treturn_edge_map::Bool=false, \n\tmultiproc::Bool=false)\n\nCompute the arrangement on the given cellular complex 1-skeleton in 2D. First part of arrangement's algorithmic pipeline. \n\n\n\n\n\n","category":"function"},{"location":"arrangement/#","page":"Arrangement","title":"Arrangement","text":"Lar.Arrangement.planar_arrangement_2","category":"page"},{"location":"arrangement/#LinearAlgebraicRepresentation.Arrangement.planar_arrangement_2","page":"Arrangement","title":"LinearAlgebraicRepresentation.Arrangement.planar_arrangement_2","text":"function planar_arrangement_2(V, copEV, bicon_comps, \n\tsigma::Lar.Chain=spzeros(Int8, 0), \n\treturn_edge_map::Bool=false, \n\tmultiproc::Bool=false)\n\nCompute the arrangement on the given cellular complex 1-skeleton in 2D. Second part of arrangement's algorithmic pipeline. \n\n\n\n\n\n","category":"function"},{"location":"arrangement/#Spatial-arrangement-1","page":"Arrangement","title":"Spatial arrangement","text":"","category":"section"},{"location":"mapper/#Solid-primitives-by-domain-mapping-1","page":"Mapper","title":"Solid primitives by domain mapping","text":"","category":"section"},{"location":"mapper/#","page":"Mapper","title":"Mapper","text":"The mapper.jl file contains the implementation of several parametric primitives, including curves, surfaces and solids embedded in either 2D or 3D.","category":"page"},{"location":"mapper/#","page":"Mapper","title":"Mapper","text":"The constructive approach is common to all methods. It consists in generating a simplicial or cuboidal decomposition of a simple geometrical domain in u,v or u,v,w parametric space. Then a change of coordinates, e.g. from Cartesian to polar or cylindrical coordinates, is applied to the vertices of the cellular complex decomposing the domain.","category":"page"},{"location":"mapper/#","page":"Mapper","title":"Mapper","text":"(Image: )","category":"page"},{"location":"mapper/#","page":"Mapper","title":"Mapper","text":"Figure 1: Cellular 3-complexes, slightly exploded: (a) cuboidal mesh; (b) simplicial mesh.","category":"page"},{"location":"mapper/#","page":"Mapper","title":"Mapper","text":"So, the mapped domain produces a curved manifold in 2D or 3D space. To obtain a closed curved surface, i.e. a manifold-without-boundary, as in the case of a 2-sphere in 3D, or of the toroidal surface in 3D, a suitable identification of coincident mapped points is performed. ","category":"page"},{"location":"mapper/#Basics-of-LAR-models-1","page":"Mapper","title":"Basics of LAR models","text":"","category":"section"},{"location":"mapper/#","page":"Mapper","title":"Mapper","text":"A very simple LAR model is a 2D square with a vertex on the origin: ","category":"page"},{"location":"mapper/#","page":"Mapper","title":"Mapper","text":"julia> square=([[0.; 0] [0; 1] [1; 0] [1; 1]], [[1,2,3,4]], [[1,2], [1,3], [2,4], [3,4]])\n([0.0 0.0 1.0 1.0; 0.0 1.0 0.0 1.0], Array{Int64,1}[[1, 2, 3, 4]], Array{Int64,1}[[1, 2],\n[1, 3], [2, 4], [3, 4]])\n","category":"page"},{"location":"mapper/#","page":"Mapper","title":"Mapper","text":"Conventional names for the arrays of vertices, faces and edges:","category":"page"},{"location":"mapper/#","page":"Mapper","title":"Mapper","text":"julia> V,FV,EV = square\n([0.0 0.0 1.0 1.0; 0.0 1.0 0.0 1.0], Array{Int64,1}[[1, 2, 3, 4]], Array{Int64,1}[[1, 2],\n[1, 3], [2, 4], [3, 4]])","category":"page"},{"location":"mapper/#","page":"Mapper","title":"Mapper","text":"V may be either of type Array{Float64,2} or Array{Int64,2}","category":"page"},{"location":"mapper/#","page":"Mapper","title":"Mapper","text":"julia> Lar = LinearAlgebraicRepresentation\n\njulia> V::Lar.Points\n2√ó4 Array{Float64,2}:\n 0.0  0.0  1.0  1.0\n 0.0  1.0  0.0  1.0","category":"page"},{"location":"mapper/#","page":"Mapper","title":"Mapper","text":"The arrays containing the p-dimensional (2leq pleq d) cells of a d-complex must be of type Array{Array{Int64,1},1}, where each element contains the unordered array of indices of vertices on the boundary of the cell:","category":"page"},{"location":"mapper/#","page":"Mapper","title":"Mapper","text":"julia> EV::Lar.Cells\n4-element Array{Array{Int64,1},1}:\n [1, 2]\n [1, 3]\n [2, 4]\n [3, 4]","category":"page"},{"location":"mapper/#*Cuboidal*-and-*simplicial*-grids-1","page":"Mapper","title":"Cuboidal and simplicial grids","text":"","category":"section"},{"location":"mapper/#","page":"Mapper","title":"Mapper","text":"LinearAlgebraicRepresentation, as its ancestor geometric language PLaSM and its father library pyplasm aims to be multidimensional. Hence some functions generate geometric models of varying dimensions. Important examples are cuboidGrid and simplexGrid, whose unique parameter is the shape of the generated mesh, i.e. the number of d-dimensional cells in each dimension, with d = length(shape). The vertices of the mesh stay on the integer grid of suitable dimension and size.","category":"page"},{"location":"mapper/#","page":"Mapper","title":"Mapper","text":"julia> shape = [1,1,1]\n\njulia> Lar.cuboidGrid(shape)\n([0.0 0.0 ‚Ä¶ 1.0 1.0; 0.0 0.0 ‚Ä¶ 1.0 1.0; 0.0 1.0 ‚Ä¶ 0.0 1.0], \nArray{Int64,1}[[1, 2, 3, 4, 5, 6, 7, 8]])","category":"page"},{"location":"mapper/#","page":"Mapper","title":"Mapper","text":"Hence we have, for single-cell 1-, 2-, 3-, and 4-dimensional LAR models:","category":"page"},{"location":"mapper/#","page":"Mapper","title":"Mapper","text":"julia> Lar.cuboidGrid([1])\n([0.0 1.0], Array{Int64,1}[[1, 2]])\n\njulia> Lar.cuboidGrid([1,1])\n([0.0 0.0 1.0 1.0; 0.0 1.0 0.0 1.0], Array{Int64,1}[[1, 2, 3, 4]])\n\njulia> Lar.cuboidGrid([1,1,1])\n([0.0 0.0 ‚Ä¶ 1.0 1.0; 0.0 0.0 ‚Ä¶ 1.0 1.0; 0.0 1.0 ‚Ä¶ 0.0 1.0], \nArray{Int64,1}[[1, 2, 3, 4, 5, 6, 7, 8]])\n\njulia> Lar.cuboidGrid([1,1,1,1])\n([0.0 0.0 ‚Ä¶ 1.0 1.0; 0.0 0.0 ‚Ä¶ 1.0 1.0; 0.0 0.0 ‚Ä¶ 1.0 1.0; 0.0 1.0 ‚Ä¶ 0.0 1.0],\nArray{Int64,1}[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]])","category":"page"},{"location":"mapper/#","page":"Mapper","title":"Mapper","text":"Two examples follows for a  20times 20  mesh in 2D, and a 20times 20times 20   mesh in 3D. Of course, their highest dimensional cells (quads and hexs) have 4 and 8 vertices, respectively.","category":"page"},{"location":"mapper/#","page":"Mapper","title":"Mapper","text":"julia> Lar.cuboidGrid([20,20])\n([0.0 0.0 ‚Ä¶ 20.0 20.0; 0.0 1.0 ‚Ä¶ 19.0 20.0], Array{Int64,1}[[1, 2, 22, 23], [2, 3, 23,\n24], [3, 4, 24, 25], [4, 5, 25, 26], [5, 6, 26, 27], [6, 7, 27, 28], [7, 8, 28, 29], [8,\n9, 29, 30], [9, 10, 30, 31]  ‚Ä¶  [415, 416, 436, 437], [416, 417, 437, 438], [417, 418,\n438, 439], [418, 419, 439, 440], [419, 420, 440, 441]])\n\njulia> Lar.cuboidGrid([20,20,20])\n([0.0 0.0 ‚Ä¶ 20.0 20.0; 0.0 0.0 ‚Ä¶ 20.0 20.0; 0.0 1.0 ‚Ä¶ 19.0 20.0], Array{Int64,1}[[1, 2,\n22, 23, 442, 443, 463, 464], [2, 3, 23, 24, 443, 444, 464, 465], [3, 4, 24, 25, 444, 445,\n465, 466]  ‚Ä¶   [8797, 8798, 8818, 8819, 9238, 9239, 9259, 9260], [8798, 8799, 8819, 8820,\n9239, 9240, 9260, 9261]])","category":"page"},{"location":"mapper/#","page":"Mapper","title":"Mapper","text":"(Image: )","category":"page"},{"location":"mapper/#","page":"Mapper","title":"Mapper","text":"Figure 2: Cellular 3-complexes: (a) cuboidal mesh, with  0-, 1-, 2-, and 3-cells numbered with different colors; (b) exploded simplicial mesh, with 6 tetrahedra (3-cells) per mesh cube.","category":"page"},{"location":"mapper/#","page":"Mapper","title":"Mapper","text":"Similarly, you can generate a multidimensional mesh of d-simplexes (d=123dots) with the simplexGrid function, having as single parameter the (cuboidal) shape of the mesh.","category":"page"},{"location":"mapper/#","page":"Mapper","title":"Mapper","text":"Let us generate d (increasing in dimension) simplicial complexes partitioning a single hypercube 01^d:","category":"page"},{"location":"mapper/#","page":"Mapper","title":"Mapper","text":"julia> Lar.simplexGrid([1]) # one segment in [0,1] \n# output\n([0.0 1.0], Array{Int64,1}[[1, 2]])\n\njulia> Lar.simplexGrid([1,1]) # two triangles in [0,1]^2 \n# output\n([0.0 1.0 0.0 1.0; 0.0 0.0 1.0 1.0], Array{Int64,1}[[1, 2, 3], [2, 3, 4]])\n\njulia> Lar.simplexGrid([1,1,1])  # six tetrahedra in [0,1]^3 \n# output\n([0.0 1.0 ‚Ä¶ 0.0 1.0; 0.0 0.0 ‚Ä¶ 1.0 1.0; 0.0 0.0 ‚Ä¶ 1.0 1.0], Array{Int64,1}[[1, 2, 3, 5],\n[2, 3, 5, 6], [3, 5, 6, 7], [2, 3, 4, 6], [3, 4, 6, 7], [4, 6, 7, 8]])\n\njulia> Lar.simplexGrid([1,1,1,1])  # 24 pentatopes in [0,1]^4 \n# output\n([0.0 1.0 ‚Ä¶ 0.0 1.0; 0.0 0.0 ‚Ä¶ 1.0 1.0; 0.0 0.0 ‚Ä¶ 1.0 1.0; 0.0 0.0 ‚Ä¶ 1.0 1.0],\nArray{Int64,1}[[1, 2, 3, 5, 9], [2, 3, 5, 9, 10], [3, 5, 9, 10, 11], [5, 9, 10, 11, 13],\n[2, 3, 5, 6, 10]  ‚Ä¶  [4, 6, 7, 11, 12], [6, 7, 11, 12, 14], [7, 11, 12, 14, 15], [4, 6, 7,\n8, 12], [6, 7, 8, 12, 14], [7, 8, 12, 14, 15], [8, 12, 14, 15, 16]]) ","category":"page"},{"location":"mapper/#","page":"Mapper","title":"Mapper","text":"Then look at the simplicial partition (3D triangulation) of the domain 020times020times020 subset mathbfR^3 shown in Figure 1b, and generated by the Julia expression below:","category":"page"},{"location":"mapper/#","page":"Mapper","title":"Mapper","text":"julia> Lar.simplexGrid([20,20,20]) \n# output\n([0.0 1.0 ‚Ä¶ 19.0 20.0; 0.0 0.0 ‚Ä¶ 20.0 20.0], Array{Int64,1}[[1, 2, 22], [2, 22, 23], [2,\n3, 23], [3, 23, 24], [3, 4, 24], [4, 24, 25], [4, 5, 25], [5, 25, 26], [5, 6, 26], [6, 26,\n27]  ‚Ä¶  [415, 416, 436], [416, 436, 437], [416, 417, 437], [417, 437, 438], [417, 418,\n438], [418, 438, 439], [418, 419, 439], [419, 439, 440], [419, 420, 440], [420, 440,\n441]]) ","category":"page"},{"location":"mapper/#List-of-currently-available-primitives-1","page":"Mapper","title":"List of currently available primitives","text":"","category":"section"},{"location":"mapper/#","page":"Mapper","title":"Mapper","text":"The mapper module aims to provide the tools needed to apply both dimension-independent affine transformations and general simplicial maps to geometric objects and assemblies developed within the LAR scheme. A large number of surfaces and primitives solids are definable using the map function and the local parametrization.","category":"page"},{"location":"mapper/#Curves-1","page":"Mapper","title":"Curves","text":"","category":"section"},{"location":"mapper/#","page":"Mapper","title":"Mapper","text":"Primitive one-dimensional objects:","category":"page"},{"location":"mapper/#","page":"Mapper","title":"Mapper","text":"circle - Circle centered in the origin\nhelix - Helix curve about the z axis ","category":"page"},{"location":"mapper/#Surfaces-1","page":"Mapper","title":"Surfaces","text":"","category":"section"},{"location":"mapper/#","page":"Mapper","title":"Mapper","text":"(Image: )","category":"page"},{"location":"mapper/#","page":"Mapper","title":"Mapper","text":"Figure 3: Cellular 1- and 2-complexes: (a) 2D unit circle; (b) spiral curve embedded in 3D; (c) 2D unit disk; (3) spiraloid surface in 3D.","category":"page"},{"location":"mapper/#","page":"Mapper","title":"Mapper","text":"Primitive two-dimensional objects:","category":"page"},{"location":"mapper/#","page":"Mapper","title":"Mapper","text":"disk - Disk centered in the origin\nhelicoid - Helicoid about the z axis\nring - Ring centered in the origin\ncylinder - Cylinder surface with z axis\nsphere - Spherical surface of given radius\ntoroidal - Toroidal surface of given radiuses\ncrown - Half-toroidal surface of given radiuses","category":"page"},{"location":"mapper/#","page":"Mapper","title":"Mapper","text":"(Image: )","category":"page"},{"location":"mapper/#","page":"Mapper","title":"Mapper","text":"Figure 4: Cellular 2- and 3-complexes: (a) 2D disk; (b) cylinder surface in 3D; (c) 2-sphere surface in 3D; (3) toroidal surface in 3D.","category":"page"},{"location":"mapper/#Solids-1","page":"Mapper","title":"Solids","text":"","category":"section"},{"location":"mapper/#","page":"Mapper","title":"Mapper","text":"Primitive three-dimensional objects:","category":"page"},{"location":"mapper/#","page":"Mapper","title":"Mapper","text":"cuboid - Solid cuboid of given extreme vectors\nball - Solid Sphere of given radius\nrod - Solid cylinder of given radius and height\nhollowCyl - Hollow cylinder of given radiuses and height \nhollowBall - Hollow sphere of given radiuses\ntorus - Solid torus of given radiuses\npizza - Solid pizza of given radiuses","category":"page"},{"location":"mapper/#","page":"Mapper","title":"Mapper","text":"(Image: )","category":"page"},{"location":"mapper/#","page":"Mapper","title":"Mapper","text":"Figure 5: Cellular complexes: (a) 1-skeleton of 3D cube; (b) assembly of cell complexes of mixed dimensions; (c) 3-mesh of portion of hollow solid cylinder; (d) 3-mesh of a portion of hollow solid torus.","category":"page"},{"location":"mapper/#Implementation-1","page":"Mapper","title":"Implementation","text":"","category":"section"},{"location":"mapper/#","page":"Mapper","title":"Mapper","text":"The coding of the generating functions for the various geometric primitives follows the below guidelines:","category":"page"},{"location":"mapper/#","page":"Mapper","title":"Mapper","text":"*\t Higher level function interface. Every generating function is of type fun parms_1 to (parms_2 to results) with parms_1=p_1times p_2times cdots times p_m and parms_2=q_1times q_2times cdots times q_n. The p_i parameters concern the specification of the coordinate functions of the mapping. The q_j parameters (1leq jleq nin123)  affect the discretization of mapping domain.","category":"page"},{"location":"mapper/#","page":"Mapper","title":"Mapper","text":"*\t Simplicial or cuboidal decomposition.  Discretization primitives simplexGrid() or cuboidGrid() are used for the two cases. Both primitives are dimension-independent, i.e. may decompose 1D, 2D, 3D,..., nD domains, depending only on the array shape of the generated cellular complex. The complex is generated in LAR format (vertices,cells), where vertices have integer coordinates. ","category":"page"},{"location":"mapper/#","page":"Mapper","title":"Mapper","text":"*\t Coordinate functions. Are applied to the integer vertices, so producing their mapped instances and store them in a Array{Array{Int64,1},1}","category":"page"},{"location":"mapper/#","page":"Mapper","title":"Mapper","text":"*\tComplex simplification. Finally, the geometrically coincident vertices are identified, the generated cells are translated to the new vertex indices, and cells are simplified from multiple identical indices. This may induce the sewing of domain boundaries according to expected topology of the curved manifold and/or the reduction of independent vertices in cells of the complex.","category":"page"},{"location":"mapper/#Main-Interface-1","page":"Mapper","title":"Main Interface","text":"","category":"section"},{"location":"mapper/#Curve-primitives-1","page":"Mapper","title":"Curve primitives","text":"","category":"section"},{"location":"mapper/#","page":"Mapper","title":"Mapper","text":"Lar.circle","category":"page"},{"location":"mapper/#LinearAlgebraicRepresentation.circle","page":"Mapper","title":"LinearAlgebraicRepresentation.circle","text":"circle(radius=1.; angle=2*pi)(shape=36)\n\nCompute an approximation of the circunference curve in 2D, centered on the origin.\n\nWith default values, i.e. circle()(), return the whole circonference of unit radius, approximated with a shape=36 number of 1-cells.\n\nExample\n\njulia> W,CW = Lar.circle()();\n\njulia> using Plasm\n\njulia> Plasm.view(W, CW)\n\n\n\n\n\n","category":"function"},{"location":"mapper/#","page":"Mapper","title":"Mapper","text":"Lar.helix","category":"page"},{"location":"mapper/#LinearAlgebraicRepresentation.helix","page":"Mapper","title":"LinearAlgebraicRepresentation.helix","text":"helix(radius=1., pitch=1., nturns=2)(shape=36*nturns)\n\nCompute the approximate elix curve in three-dimensional space, with basis on z=0 plane and centered around the z axis. The pitch of a helix is the height of one complete helix turn, measured parallel to the axis of the helix.\n\nExample\n\njulia> V, CV = Lar.helix(.1, .1, 10)()\n# output\n([0.1 0.0984808 ‚Ä¶ 0.0984808 0.1; 0.0 0.0173648 ‚Ä¶ -0.0173648 0.0; 0.0 0.0027778 ‚Ä¶ 0.997222 1.0], Array{Int64,1}[[1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 8], [8, 9], [9, 10], [10, 11]  ‚Ä¶  [351, 352], [352, 353], [353, 354], [354, 355], [355, 356], [356, 357], [357, 358], [358, 359], [359, 360], [360, 361]])\n\njulia> using Plasm\n\njulia> Plasm.view(V, CV)\n\n\n\n\n\n","category":"function"},{"location":"mapper/#Surface-primitives-1","page":"Mapper","title":"Surface primitives","text":"","category":"section"},{"location":"mapper/#","page":"Mapper","title":"Mapper","text":"Lar.disk","category":"page"},{"location":"mapper/#LinearAlgebraicRepresentation.disk","page":"Mapper","title":"LinearAlgebraicRepresentation.disk","text":"disk(radius=1., angle=2*pi)(shape=[36, 1])\n\nCompute the cellular complex approximating a circular sector of 2D disk centered on the origin. In geometry, a disk is the region in a plane bounded by a circle. The shape array provides the number of approximating 2-cells.\n\nExample\n\njulia> Lar.disk()()\n# output\n([0.0 0.5 ‚Ä¶ 0.939693 0.984808; 0.0 0.0 ‚Ä¶ -0.34202 -0.173648], Array{Int64,1}[[1, 2, 3], [1, 3, 4], [1, 4, 5], [1, 5, 6], [1, 6, 7], [1, 7, 8], [1, 8, 9], [1, 9, 10], [1, 10, 11], [1, 11, 12]  ‚Ä¶  [33, 34, 69], [34, 69, 70], [34, 35, 70], [35, 70, 71], [35, 36, 71], [36, 71, 72], [36, 37, 72], [37, 72, 73], [37, 2, 73], [2, 73, 38]])\n\njulia> using Plasm\n\njulia> Plasm.view(Lar.disk()())\n\n\n\n\n\n","category":"function"},{"location":"mapper/#","page":"Mapper","title":"Mapper","text":"Lar.helicoid","category":"page"},{"location":"mapper/#LinearAlgebraicRepresentation.helicoid","page":"Mapper","title":"LinearAlgebraicRepresentation.helicoid","text":"helicoid(R=1., r=0.5, pitch=1., nturns=2)(shape=[36*nturns, 2])\n\nCompute an approximation of the helicoid surface in 3D, with basis on z=0 plane and centered around the z axis.\n\nExample\n\njulia> using Plasm\n\njulia>  Plasm.view(Lar.helicoid()())\n\n\n\n\n\n","category":"function"},{"location":"mapper/#","page":"Mapper","title":"Mapper","text":"Lar.ring","category":"page"},{"location":"mapper/#LinearAlgebraicRepresentation.ring","page":"Mapper","title":"LinearAlgebraicRepresentation.ring","text":"ring(r=1., R=2., angle=2*pi)(shape=[36, 1])\n\nCompute the cellular 2-complex approximating a (possibly full) sector of a non-contractible disk. R and r are the external and the internal radiuses, respectively.\n\nExample\n\njulia> using Plasm\n\njulia> Plasm.view(Lar.ring()())\n\n\n\n\n\n","category":"function"},{"location":"mapper/#","page":"Mapper","title":"Mapper","text":"Lar.cylinder","category":"page"},{"location":"mapper/#LinearAlgebraicRepresentation.cylinder","page":"Mapper","title":"LinearAlgebraicRepresentation.cylinder","text":"cylinder(radius=.5, height=2., angle=2*pi)(shape=[36, 1])\n\nCompute a cellular 2-complex, approximation of a right circular cylindrical surface in 3D. The open surface has basis on z=0 plane and is centered around the z axis.\n\nExample\n\njulia> using Plasm\n\njulia> Plasm.view(Lar.cylinder()())\n\n\n\n\n\n","category":"function"},{"location":"mapper/#","page":"Mapper","title":"Mapper","text":"Lar.sphere","category":"page"},{"location":"mapper/#","page":"Mapper","title":"Mapper","text":"Lar.toroidal","category":"page"},{"location":"mapper/#LinearAlgebraicRepresentation.toroidal","page":"Mapper","title":"LinearAlgebraicRepresentation.toroidal","text":"toroidal(r=1., R=2., angle1=2*pi, angle2=2*pi)(shape=[24, 36])\n\nCompute a cellular 2-complex, approximation of the two-dimensional surface, embedded in a three-dimensional Euclidean space.  Toroidal is a closed surface having genus one, and therefore possessing a single \"hole\".  It can be constructed from a rectangle by gluing both pairs of opposite edges together with no twists.\n\nExample\n\njulia> using Plasm\n\njulia> Plasm.view(Lar.toroidal()())\n\n\n\n\n\n","category":"function"},{"location":"mapper/#Solid-primitives-1","page":"Mapper","title":"Solid primitives","text":"","category":"section"},{"location":"mapper/#","page":"Mapper","title":"Mapper","text":"Lar.cuboid","category":"page"},{"location":"mapper/#LinearAlgebraicRepresentation.cuboid","page":"Mapper","title":"LinearAlgebraicRepresentation.cuboid","text":"cuboid(maxpoint::Array, full=false, minpoint::Array=zeros(length(maxpoint)))\n\nReturn a d-dimensional cube, where d is the common length of arrays minpoint and maxpoint.  If flag=true the cells of all dimensions (between 1 and d) are generated.\n\njulia> Lar.cuboid([-0.5, -0.5])\n# output\n([0.0 0.0 -0.5 -0.5; 0.0 -0.5 0.0 -0.5], Array{Int64,1}[[1, 2, 3, 4]])\n\njulia> Lar.cuboid([-0.5, -0.5, 0], true)\n# output\n([0.0 0.0 ‚Ä¶ -0.5 -0.5; 0.0 0.0 ‚Ä¶ -0.5 -0.5; 0.0 0.0 ‚Ä¶ 0.0 0.0],\nArray{Array{Int64,1},1}[Array{Int64,1}[[1], [2], [3], [4], [5], [6], [7], [8]],\nArray{Int64,1}[[1, 2], [3, 4], [5, 6], [7, 8], [1, 3], [2, 4], [5, 7], [6, 8], [1, 5], [2,\n6], [3, 7], [4, 8]], Array{Int64,1}[[1, 2, 3, 4], [5, 6, 7, 8], [1, 2, 5, 6], [3, 4, 7,\n8], [1, 3, 5, 7], [2, 4, 6, 8]], Array{Int64,1}[[1, 2, 3, 4, 5, 6, 7, 8]]])\n\njulia> V, (VV, EV, FV, CV) = Lar.cuboid([1,1,1], true);\n\njulia> assemby = Lar.Struct([ (V, EV), Lar.t(1,0,0), (V, CV) ])\n\njulia> using Plasm\n\njulia> Plasm.view(Lar.struct2lar(assemby))\n\n\n\n\n\n","category":"function"},{"location":"mapper/#","page":"Mapper","title":"Mapper","text":"Lar.ball","category":"page"},{"location":"mapper/#LinearAlgebraicRepresentation.ball","page":"Mapper","title":"LinearAlgebraicRepresentation.ball","text":"ball(radius=1, angle1=pi, angle2=2*pi)(shape=[18, 36,4])\n\nGenerate a cell decomposition of a solid 3-sphere in R^3. The variable shape provides the domain decomposition. Empty cells are removed after the Cartesian -> Polar coordinate mapping.\n\nExample\n\njulia> using Plasm\n\njulia> Plasm.view(Lar.ball()())\n\n\n\n\n\n","category":"function"},{"location":"mapper/#","page":"Mapper","title":"Mapper","text":"Lar.hollowCyl","category":"page"},{"location":"mapper/#LinearAlgebraicRepresentation.hollowCyl","page":"Mapper","title":"LinearAlgebraicRepresentation.hollowCyl","text":"hollowCyl(r=1., R=2., height=6., angle=2*pi)(shape=[36, 1, 1])\n\nCompute the cellular 3-complex approximating a solid cylinder with a   internal axial hole. The model is meshed with cubical 3-cells.\n\nExample\n\njulia> using Plasm\n\njulia> Plasm.view(Lar.hollowCyl()())\n\n\n\n\n\n","category":"function"},{"location":"mapper/#","page":"Mapper","title":"Mapper","text":"Lar.hollowBall","category":"page"},{"location":"mapper/#LinearAlgebraicRepresentation.hollowBall","page":"Mapper","title":"LinearAlgebraicRepresentation.hollowBall","text":"hollowBall(r=1., R=2., angle1=pi, angle2=2*pi)(shape=[36, 1, 1])\n\nCompute the cellular 3-complex approximating a 3-sphere. The model is meshed with cubical 3-cells, where the mesh has default decomposition size [24, 36, 8].\n\nExample\n\njulia> V, CV = Lar.hollowBall(1, 2, pi/2, pi/2)([6, 12, 4]);\n\njulia> using Plasm\n\njulia> Plasm.view(V, CV)\n...\n\n\n\n\n\n","category":"function"},{"location":"mapper/#","page":"Mapper","title":"Mapper","text":"Lar.torus","category":"page"},{"location":"mapper/#LinearAlgebraicRepresentation.torus","page":"Mapper","title":"LinearAlgebraicRepresentation.torus","text":"torus(r=1., R=2., h=.5, angle1=2*pi, angle2=2*pi)(shape=[24, 36, 4])\n\nCompute the cellular 3-complex approximating the solid torus in 3D. The model is meshed with cubical 3-cells, where the mesh has default decomposition size [24, 36, 4]. See also: toroidal. h is radius of the circular hole inside the solid.\n\nExample\n\njulia> using Plasm\n\njulia> Plasm.view(Lar.torus(1., 2., .5, pi, pi)())\n\n\n\n\n\n","category":"function"},{"location":"struct/#Assemblies-of-cellular-complexes-1","page":"Assemblies","title":"Assemblies of cellular complexes","text":"","category":"section"},{"location":"struct/#","page":"Assemblies","title":"Assemblies","text":"Hierarchical models of complex assemblies are generated by aggregation of cellular complexes, each one defined in a local coordinate system, and possibly relocated by affine transformations of coordinates.  This operation may be repeated hierarchically, with subassemblies defined by aggregation of simpler parts, and so on, until to obtain a set of LAR models, which are not further decomposed.","category":"page"},{"location":"struct/#","page":"Assemblies","title":"Assemblies","text":"(Image: )","category":"page"},{"location":"struct/#","page":"Assemblies","title":"Assemblies","text":"Figure 1: Hierarchical assembly of cellular 3-complexes.","category":"page"},{"location":"struct/#","page":"Assemblies","title":"Assemblies","text":"Two main advantages can be found in a hierarchical modeling approach. Each component complex  and each assembly, at every hierarchical level, are defined independently from each other, using a local coordinate frame, suitably chosen to make its definition easier. Furthermore, only one copy of each component is stored in memory, and may be instanced in different locations and orientations how many times it is needed.","category":"page"},{"location":"struct/#","page":"Assemblies","title":"Assemblies","text":"(Image: )","category":"page"},{"location":"struct/#","page":"Assemblies","title":"Assemblies","text":"Figure 2: Hierarchical assembly of a 2-complex consisting of a single 2-cell (the square): (a) 2-skeleton; (b) 1-skeleton of the resulting complex.","category":"page"},{"location":"struct/#Hierarchical-graphs-1","page":"Assemblies","title":"Hierarchical graphs","text":"","category":"section"},{"location":"struct/#","page":"Assemblies","title":"Assemblies","text":"A hierarchical model, defined inductively as an assembly of component parts, is described by an acyclic directed multigraph, often called a scene graph or hierarchical structure in computer graphics and modeling.  The main algorithm with hierarchical assemblies is the traversal function, which transforms every component from local coordinates to global coordinates, called world coordinates.","category":"page"},{"location":"struct/#Acyclic-directed-multigraph-1","page":"Assemblies","title":"Acyclic directed-multigraph","text":"","category":"section"},{"location":"struct/#","page":"Assemblies","title":"Assemblies","text":"The standard definition of a directed graph G states that it is a pair (NA), where N is a set of nodes and A is a set of directed arcs, given as ordered pairs of nodes.  Such a definition is not sufficient when more than one arc must be considered between the same pair of nodes.","category":"page"},{"location":"struct/#","page":"Assemblies","title":"Assemblies","text":"In this case the notion of multigraph is introduced.  A directed multigraph is a triplet G = (NAf) where N and A are sets of nodes and arcs, respectively, and f A to mathbfN^2 is a mapping from arcs to node pairs.  In other words, in a multigraph, the same pair of nodes can be connected by multiple arcs.","category":"page"},{"location":"struct/#","page":"Assemblies","title":"Assemblies","text":"Directed graphs or multigraphs are said to be acyclic when they do not contain cycles, i.e. when no path starts and ends at the same vertex.  Trees are common examples of acyclic graphs. A tree, where each non-leaf node is the root of a subtree, is the best model of the concept of hierarchy. Nodes in a tree can be associated with their integer distance from the root, defined by the number of edges on the unique path from the root to the node.  A tree can be layered by levels, by putting in the same subset (level) all the nodes with equal distance from the root.  ","category":"page"},{"location":"struct/#","page":"Assemblies","title":"Assemblies","text":"Acyclic graphs/multigraphs are also called hierarchical graphs, because they can be associated to a tree, generated at run-time by visiting the graph with some standard traversal algorithm, e.g. with a depth-first-search.  The ordered sequence of nodes produced by the traversal is sometimes called a linearized graph.  Each node in this sequence is suitably transformed from local coordinates to world coordinates, i.e. to the coordinates of the root, by the traversal algorithm.","category":"page"},{"location":"struct/#Hierarchical-structures-1","page":"Assemblies","title":"Hierarchical structures","text":"","category":"section"},{"location":"struct/#","page":"Assemblies","title":"Assemblies","text":"Various kinds of hierarchical assemblies are used in standard graphical systems, such as GKS, PHIGS and VRML, as well as in graphics libraries like Open Inventor and Java 3D.  The type of hierarchical structures adopted here is inspired, even in the name of the function used for this purpose, by the one introduced by PHIGS, i.e. Struct.","category":"page"},{"location":"struct/#","page":"Assemblies","title":"Assemblies","text":"The arcs of scene graphs are normally specified implicitly in real graphical systems. For example, an arc is actually specified when a node is contained or referred within another one. In particular, it is possible to specify a new container node together with either the matrix or the parameters of the transformation to be associated with the the arc that connects the new container to the current node.","category":"page"},{"location":"struct/#Examples-1","page":"Assemblies","title":"Examples","text":"","category":"section"},{"location":"struct/#Containers-of-geometric-objects-1","page":"Assemblies","title":"Containers of geometric objects","text":"","category":"section"},{"location":"struct/#","page":"Assemblies","title":"Assemblies","text":"type Struct\n\tbody::Array\n\tbox\n\tname::AbstractString\n\tdim\n\tcategory::AbstractString\nend","category":"page"},{"location":"struct/#","page":"Assemblies","title":"Assemblies","text":"where body::Array is the actual container, which may contain geometric models, affine transformations, and other structure values; box is a representation of the containment box; name is an identifier, initialized to the id of the empty object created by the constructor Struct(); dim is the dimension of the embedding space, i.e. the number of coordinates; category is a property of the created value, initializated to \"feature\".","category":"page"},{"location":"struct/#","page":"Assemblies","title":"Assemblies","text":"A typical LAR geometrical model is a Tuple (triple or pair), where the first element is the matrix of coordinates of vertices, and the remaining arrays of array of integers provide the vertex indices of each cell. ","category":"page"},{"location":"struct/#","page":"Assemblies","title":"Assemblies","text":"julia> square = ([[0; 0] [0; 1] [1; 0] [1; 1]], [[1, 2, 3,\n4]], [[1,2], [1,3], [2,4], [3,4]])\n# output\n([0 0 1 1; 0 1 0 1], Array{Int64,1}[[1, 2, 3, 4]], Array{Int64,1}[[1, 2], [1,\n3], [2, 4], [3, 4]]) ","category":"page"},{"location":"struct/#","page":"Assemblies","title":"Assemblies","text":"A container of geometrical objects is defined by applying the function Struct to the array of contained objects.  The value returned from the application is a value of  Struct type.  The coordinate system of this value is the one associated with the first object of the Struct parameters.  Also, the resulting geometrical value is often associated with a variable name.","category":"page"},{"location":"struct/#Affine-transformations-and-containers-1","page":"Assemblies","title":"Affine transformations and containers","text":"","category":"section"},{"location":"struct/#","page":"Assemblies","title":"Assemblies","text":"Affine transformations or tensor matrices, of type Arra{Float64, 2}, are created by functions","category":"page"},{"location":"struct/#","page":"Assemblies","title":"Assemblies","text":"Lar.t(args...)\t# for translation\nLar.s(args...)\t# for scaling\nLar.r(args...)\t# for rotation","category":"page"},{"location":"struct/#","page":"Assemblies","title":"Assemblies","text":"An affine 3times 3 transformation matrix, generated in homogeneous normalized coordinates by the function call t(-0.5,-0.5), can be applied to a LAR object obj both explicitly by using the function apply(Matrix, obj) or implicitly by creating a Struct hierarchical object, as shown by the following examples:","category":"page"},{"location":"struct/#","page":"Assemblies","title":"Assemblies","text":"julia> Lar = LinearAlgebraicRepresentation\n\njulia> table = Lar.apply( Lar.t(-0.5,-0.5), square )\n# output\n([-0.5 -0.5 0.5 0.5; -0.5 0.5 -0.5 0.5], Array{Int64,1}[[1, 2, 3, 4]],\nArray{Int64,1}[[1, 2], [1, 3], [2, 4], [3, 4]])\n\njulia> table = Lar.Struct([ Lar.t(-0.5,-0.5), square ])\n# output\nStruct(Any[[1.0 0.0 -0.5; 0.0 1.0 -0.5; 0.0 0.0 1.0], ([0 0 1 1; 0 1 0 1],\nArray{Int64,1}[[1, 2, 3, 4]], Array{Int64,1}[[1, 2], [1, 3], [2, 4], [3, 4]])],\nArray[[-0.5; -0.5], [0.5; 0.5]], \"10234090646332247690\", 2, \"feature\") ","category":"page"},{"location":"struct/#","page":"Assemblies","title":"Assemblies","text":"The generation of container nodes may continue hierarchically by suitably applying Struct. Notice that each LAR object in a Struct container is transformed by each matrix before it within the container, going from right to left. The action of a transformation (tensor) extends to each object on its right within its own container. Whereas,  the action of a tensor does not extend outside its container, according to the semantics of PHIGS structures.","category":"page"},{"location":"struct/#","page":"Assemblies","title":"Assemblies","text":"chair = Lar.Struct([ Lar.t(0.75,0), Lar.s(0.35,0.35), table ])","category":"page"},{"location":"struct/#Container-evaluation-1","page":"Assemblies","title":"Container evaluation","text":"","category":"section"},{"location":"struct/#","page":"Assemblies","title":"Assemblies","text":"The function evalStruct, when applied to a Struct value, generates an Array of LAR models, each one originally defined  in a local coordinate system, transforming all of them in the same world coordinate, equal to the ones of the first object in the Struct parameter sequence.","category":"page"},{"location":"struct/#","page":"Assemblies","title":"Assemblies","text":"Conversely, the struct2lar function generates a single LAR model (cellular complex), whose components are here assigned respectively to variables W (coordinates of vertices), FW faces (2-cells), and EW edges (1-cells). Notice that the whole model is embedded in 2D, since the W array (coordinates by columns) has two rows","category":"page"},{"location":"struct/#","page":"Assemblies","title":"Assemblies","text":"scene = Lar.evalStruct(struct02)\t# array of LAR models\nW,FW,EW = Lar.struct2lar(struct02)\t# single LAR model","category":"page"},{"location":"struct/#Simple-assembly-examples-1","page":"Assemblies","title":"Simple assembly examples","text":"","category":"section"},{"location":"struct/#","page":"Assemblies","title":"Assemblies","text":"The object struct0 below contains a table and 4 chairs, struct01 is a row of 10 suitably translated instances of struct0, and struct02 is another assembly of suitably translated struct01 instances. ","category":"page"},{"location":"struct/#","page":"Assemblies","title":"Assemblies","text":"L = LinearAlgebraicRepresentation\nstruct0 = L.Struct([ L.t(2,1),table, repeat([L.r(pi/2), chair ], outer = 4)... ])\nstruct01 = L.struct2lar(L.Struct( repeat([ struct0, L.t(0,2.5) ], outer = 10) ));\nscene = L.struct2lar(L.Struct( repeat([ struct01, L.t(3,0) ], outer = 10) ));","category":"page"},{"location":"struct/#","page":"Assemblies","title":"Assemblies","text":"To see the generated 2D scene you need the Plasm module.","category":"page"},{"location":"struct/#","page":"Assemblies","title":"Assemblies","text":"using Plasm\nPlasm.view(scene[1],scene[2])\nPlasm.view(scene[1],scene[3])","category":"page"},{"location":"struct/#","page":"Assemblies","title":"Assemblies","text":"A different example provides a sphere, and a cylinder instance suitably translated, within the same Struct container. Of course, we could define a hierarchical assembly of any size and deep, containing any number of Struct nodes.","category":"page"},{"location":"struct/#","page":"Assemblies","title":"Assemblies","text":"warning: Warning\n2D surfaces embedded in 3D are normally displayed in Plasm as made of unoriented 2-cells. In order to get a better dispaly, the user should press the t or T keys on the keyboard.","category":"page"},{"location":"struct/#","page":"Assemblies","title":"Assemblies","text":"assembly = L.Struct([L.sphere()(), L.t(3,0,-1), L.cylinder()()])\nusing Plasm\nPlasm.view(L.struct2lar(assembly))","category":"page"},{"location":"struct/#","page":"Assemblies","title":"Assemblies","text":"(Image: )","category":"page"},{"location":"struct/#","page":"Assemblies","title":"Assemblies","text":"Figure 3: (a) Enlargement of a portion of the exploded complex in Fig.1; (b) an assembly with two cuboidal 2-complexes (surfaces) embedded in 3D.","category":"page"},{"location":"struct/#Coding-of-3D-refectory-assembly-1","page":"Assemblies","title":"Coding of 3D refectory assembly","text":"","category":"section"},{"location":"struct/#","page":"Assemblies","title":"Assemblies","text":"The refectory model shown in Figure 1 is stepwise developed here. Of course, in order to display the various geometric models, the Plasm package is needed.","category":"page"},{"location":"struct/#","page":"Assemblies","title":"Assemblies","text":"using LinearAlgebraicRepresentation\nL = LinearAlgebraicRepresentation\n\nusing Plasm\nView = Plasm.view","category":"page"},{"location":"struct/#","page":"Assemblies","title":"Assemblies","text":"(Image: )","category":"page"},{"location":"struct/#","page":"Assemblies","title":"Assemblies","text":"Figure 4: The generation process of the refectory assembly shown in Figure 1.","category":"page"},{"location":"struct/#","page":"Assemblies","title":"Assemblies","text":"First develop the table model, starting from a single cube object, of type LAR = Tuple{Points,Cells}, suitably translated to get the base center at the origin, then create containers for tableTop, tablelegs, and table. Finally check the assembly correctness, and convert to a LAR value.  The View primitive may be applied both to  Struct and LAR values, as well to other types.","category":"page"},{"location":"struct/#","page":"Assemblies","title":"Assemblies","text":"cube = L.apply( L.t(-.5,-.5,0), L.cuboid([1,1,1]))\ntableTop = L.Struct([ L.t(0,0,.85), L.s(1,1,.05), cube ])\ntableLeg = L.Struct([ L.t(-.475,-.475,0), L.s(.1,.1,.89), cube ])\ntablelegs = L.Struct( repeat([ tableLeg, L.r(0,0,pi/2) ],outer=4) )\ntable = L.Struct([ tableTop, tablelegs ])\nView(table)\ntable = L.struct2lar(table)\nView(table)","category":"page"},{"location":"struct/#","page":"Assemblies","title":"Assemblies","text":"Then build the chair model as above. The polyhedral cylndr is defined with 8 lateral faces, and 16 vertices. ","category":"page"},{"location":"struct/#","page":"Assemblies","title":"Assemblies","text":"cylndr = L.rod(.06, .5, 2*pi)([8,1])\nchairTop = L.Struct([ L.t(0,0,0.5), L.s(0.5,0.5,0.04), cube ])\nchairLeg = L.Struct([ L.t(-.22,-.22,0), L.s(.5,.5,1), L.r(0,0,pi/8), cylndr ])\nchairlegs = L.Struct( repeat([ chairLeg, L.r(0,0,pi/2) ],outer=4) );\nchair = L.Struct([ chairTop, chairlegs ]);\nchair = L.struct2lar(chair)\nView(chair)","category":"page"},{"location":"struct/#","page":"Assemblies","title":"Assemblies","text":"Just notice that, in expanding the chair data structure, 72 vertices and five 3-cells are obtained. If a model made of quads or triangles is needed, just generate cube and cylndr using different primitives in mapper.jl file.","category":"page"},{"location":"struct/#","page":"Assemblies","title":"Assemblies","text":"julia> chair[1]\n3√ó72 Array{Float64,2}:\n -0.25  -0.25  -0.25  -0.25   0.25   0.25  0.25  0.25  ‚Ä¶  -0.247716  -0.231481  -0.231481\n -0.25  -0.25   0.25   0.25  -0.25  -0.25  0.25  0.25      0.208519   0.192284   0.192284\n  0.5    0.54   0.5    0.54   0.5    0.54  0.5   0.54      0.5        0.0        0.5     \njulia> chair[2]\n5-element Array{Array{Int64,1},1}:\n [1, 2, 3, 4, 5, 6, 7, 8]                                        \n [9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24] \n [25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40]\n [41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56]\n [57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72]","category":"page"},{"location":"struct/#","page":"Assemblies","title":"Assemblies","text":"Finally assemble the refectory model, by looping twice on a single coordinate.  Then a single LAR value is create, as well an Array{Any,1} collection of simplest LAR values, all given in Wold Coordinates.","category":"page"},{"location":"struct/#","page":"Assemblies","title":"Assemblies","text":"theChair = L.Struct([ L.t(-.8,0,0), chair ])\nfourChairs = L.Struct( repeat([L.r(0,0,pi/2), theChair],outer=4) );\nfourSit = L.Struct([fourChairs,table]);\nView(fourSit)\nsingleRow=L.Struct(repeat([fourSit,L.t(0,2.5,0)],outer=10));\nView(singleRow)\nrefectory=L.Struct(repeat([singleRow,L.t(3,0,0)],outer=10));\nView(refectory)","category":"page"},{"location":"struct/#Main-Interface-1","page":"Assemblies","title":"Main Interface","text":"","category":"section"},{"location":"struct/#","page":"Assemblies","title":"Assemblies","text":"Lar.Struct","category":"page"},{"location":"struct/#LinearAlgebraicRepresentation.Struct","page":"Assemblies","title":"LinearAlgebraicRepresentation.Struct","text":"Struct\n\nA container of geometrical objects is defined by applying the function Struct to the array of contained objects. Each value is defined in local coordinates and may be transformed by affine transformation tensors.\n\nThe value returned from the application of Struct to an Array{Any, 1} of LAR values, matrices, and Struct values is a value of  Struct type.  The coordinate system of this value is the one associated with the first object of the Struct arguments.  Also, the resulting geometrical value is often associated with a variable name.\n\nThe generation of containers may continue hierarchically by suitably applying Struct. Notice that each LAR object in a Struct container is transformed by each matrix before it within the container, going from right to left. The action of a transformation (tensor) extends to each object on its right within its own container. Whereas,  the action of a tensor does not extend outside its container, according to the semantics of PHIGS structures.\n\nExample\n\njulia> L = LinearAlgebraicRepresentation;\n\njulia> assembly = L.Struct([L.sphere()(), L.t(3,0,-1), L.cylinder()()])\n# return\nLar.Struct(Any[([0.0 -0.173648 ‚Ä¶ -0.336824 -0.17101; 0.0 0.0 ‚Ä¶ 0.0593912 0.0301537;\n-1.0 -0.984808 ‚Ä¶ 0.939693 0.984808], Array{Int64,1}[[2, 3, 1], [4, 2, 3], [4, 3, 5], [4,\n5, 6], [7, 5, 6], [7, 8, 6], [7, 9, 8], ‚Ä¶ , [1.0 0.0 0.0 3.0; 0.0 1.0 0.0 0.0; 0.0 0.0 1.0\n-1.0; 0.0 0.0 0.0 1.0], ([0.5 0.5 ‚Ä¶ 0.492404 0.492404; 0.0 0.0 ‚Ä¶ -0.0868241 -0.0868241;\n0.0 2.0 ‚Ä¶ 0.0 2.0], Array{Int64,1}[[4, 2, 3, 1], [4, 3, 5, 6], [7, 5, 8, 6], [7, 9, 10,\n8], [9, 10, 11, 12], [13, 14, 11, 12], ‚Ä¶ , [68, 66, 67, 65], [68, 69, 67, 70], [71, 69,\n72, 70], [71, 2, 72, 1]])], Array{Float64,2}[[-1.0; -1.0; -1.0], [3.5; 1.0; 1.0]],\n\"14417445522513259426\", 3, \"feature\")\n\njulia> assembly.name = \"simple example\"\n# return\n\"simple example\"\n\njulia> assembly\n# return\nLar.Struct(Any[([0.0 -0.173648 ‚Ä¶ -0.336824 -0.17101; 0.0 0.0 ‚Ä¶ 0.0593912 0.0301537;\n-1.0 -0.984808 ‚Ä¶ 0.939693 0.984808], Array{Int64,1}[[2, 3, 1], [4, 2, 3], [4, 3, 5], [4,\n5, 6], [7, 5, 6], [7, 8, 6], ‚Ä¶ , [71, 2, 72, 1]])], Array{Float64,2}[[-1.0; -1.0; -1.0],\n[3.5; 1.0; 1.0]], \"simple example\", 3, \"feature\")\n\njulia> using Plasm\n\njulia> Plasm.view(assembly)\n\n\n\n\n\n","category":"type"},{"location":"struct/#","page":"Assemblies","title":"Assemblies","text":"Lar.apply","category":"page"},{"location":"struct/#LinearAlgebraicRepresentation.apply","page":"Assemblies","title":"LinearAlgebraicRepresentation.apply","text":"apply(affineMatrix::Array{Float64,2}, larmodel::Union{LAR,LARmodel})\n\n\n\n\n\n","category":"function"},{"location":"struct/#","page":"Assemblies","title":"Assemblies","text":"Lar.struct2lar","category":"page"},{"location":"struct/#LinearAlgebraicRepresentation.struct2lar","page":"Assemblies","title":"LinearAlgebraicRepresentation.struct2lar","text":"struct2lar(structure::Struct)::Union{LAR,LARmodel}\n\n\n\n\n\n","category":"function"},{"location":"struct/#","page":"Assemblies","title":"Assemblies","text":"Lar.evalStruct","category":"page"},{"location":"struct/#LinearAlgebraicRepresentation.evalStruct","page":"Assemblies","title":"LinearAlgebraicRepresentation.evalStruct","text":"evalStruct(self)\n\n\n\n\n\n","category":"function"},{"location":"largrid/#Generation-and-product-of-multidimensional-complexes-1","page":"Cuboidal grids","title":"Generation and product of multidimensional complexes","text":"","category":"section"},{"location":"largrid/#","page":"Cuboidal grids","title":"Cuboidal grids","text":"We introduce the use of multidimensional grid generation of cuboidal and simplicial cell complexes, and the more general Cartesian product of cellular complexes. Both kind of operators, depending on the dimension of their input, may generate either full-dimensional (i.e. solid) output complexes, or lower-dimensional complexes of dimension d embedded in Euclidean space of dimension n, with dleq n.  ","category":"page"},{"location":"largrid/#","page":"Cuboidal grids","title":"Cuboidal grids","text":"E.g., just think to a mesh of 3D cubes in three-dimensional space for the first case, and to the (non-manifold) framework of boundary polygons of such cubic cells for the second case. In particular,  both n-dimensional solid grids of (hyper)-cuboidal cells and their  d-dimensional skeletons (0leq dleq n), embedded in E^n, are generated by assembling the cells produced by a number n of either 0- or 1-dimensional cell complexes, that in such lowest dimensions coincide with simplicial complexes. ","category":"page"},{"location":"largrid/#Introduction-1","page":"Cuboidal grids","title":"Introduction","text":"","category":"section"},{"location":"largrid/#","page":"Cuboidal grids","title":"Cuboidal grids","text":"First the simple implementation of lower-dimensional (say, either 0- or 1-dimensional) regular cellular complexes with integer coordinates is built. Then, the generation of either full-dimensional cuboidal complexes in E^n and  their d-skeletons (0leq dleq n) is provided, since every skeleton can be efficiently generated as a partition of cell subsets produced by the Cartesian product of a proper ordered combination of 0-1 complexes, according to the binary representation of a subset of the integer interval 02^n. For this purpose a simple and general implementation of topological product of two cellular complexes of any topology is given by the package. When applied to cellular complexes (i.e. when the coordinates of 0-cells of arguments are fixed and given) the algorithm produces a Cartesian product of its arguments.","category":"page"},{"location":"largrid/#The-base-case-1","page":"Cuboidal grids","title":"The base case","text":"","category":"section"},{"location":"largrid/#","page":"Cuboidal grids","title":"Cuboidal grids","text":"We use 0- and 1-dimensional cell complexes as the basic material for several operations, including generation of simplicial and cellular grids and topological and Cartesian product of cell complexes.  The grid_0 second-order function generates a 0-dimensional uniform complex embedding n+1 equally-spaced (at unit intervals) 0-cells within the 0n interval. It returns the cells of this 0-complex, as an array of indices to vertices. The grid_1 second-order function generates a 1-dimensional uniform complex embedding n  1-cells of unit size within the 0n interval. A larGrid function is given to generate the LAR representation of the cells of either a 0- or a 1-dimensional complex, depending on the value of a d parameter, to take values in the set 01, and providing the order of the output complex.","category":"page"},{"location":"largrid/#","page":"Cuboidal grids","title":"Cuboidal grids","text":"julia> Lar = LinearAlgebraicRepresentation\n\njulia> Lar.larGrid(10)(0)\n1√ó11 Array{Int64,2}:\n 0  1  2  3  4  5  6  7  8  9  10\n\njulia> Lar.larGrid(10)(1)\n2√ó10 Array{Int64,2}:\n 0  1  2  3  4  5  6  7  8   9\n 1  2  3  4  5  6  7  8  9  10","category":"page"},{"location":"largrid/#Dimension-independent-cuboidal-grids-1","page":"Cuboidal grids","title":"Dimension-independent cuboidal grids","text":"","category":"section"},{"location":"largrid/#","page":"Cuboidal grids","title":"Cuboidal grids","text":"More interesting is the generation of hyper-cubical grids of intrinsic dimension d embedded in n-dimensional space, via the Cartesian product of d 1-complexes and (n-d) 0-complexes. When d=n the resulting grid is said solid; when d=0 the output grid is 0-dimensional, and corresponds to a grid-arrangement of a discrete set of points in E^n.","category":"page"},{"location":"largrid/#","page":"Cuboidal grids","title":"Cuboidal grids","text":"Generation of grid cells by Cartesian product of 0/1-complexes. The output complex is generated by the product of any number of either 0- or 1-dimensional cell complexes. The product of d 1-complexes generates solid d-cells, while the product of n 0-complexes and n-d 1-complexes (d  n) generates non-solid (n-d)-cells, properly embedded in n-space, i.e. with vertices having n coordinates.","category":"page"},{"location":"largrid/#","page":"Cuboidal grids","title":"Cuboidal grids","text":"The second-order utility index2addr function transforms a multidimensional shape array into a function that, when applied to a multindex array, i.e. to a list of integers within the shape's bounds, returns the integer address of the array component, within the linear storage of the multidimensional array.","category":"page"},{"location":"largrid/#","page":"Cuboidal grids","title":"Cuboidal grids","text":"The transformation formula for a d-dimensional array with shape (n_0n_1n_d-1) is a linear combination of the 0-based multi-index (i_0i_1i_d-1) with weights equal to (w_0w_1w_d-21):","category":"page"},{"location":"largrid/#","page":"Cuboidal grids","title":"Cuboidal grids","text":"addr = i_0times w_0 +i_1times w_1 +cdots +i_d-1times w_d-1","category":"page"},{"location":"largrid/#","page":"Cuboidal grids","title":"Cuboidal grids","text":"where ","category":"page"},{"location":"largrid/#","page":"Cuboidal grids","title":"Cuboidal grids","text":"w_k = n_k+1 times n_k+2 timescdotstimes  n_d-1 qquad 0leq kleq d-2","category":"page"},{"location":"largrid/#","page":"Cuboidal grids","title":"Cuboidal grids","text":"Therefore, we get index2addr([4,3,6])([2,2,0])=48=2times(3times 6)+2times(6times 1)+0, where [2,2,0] represent the numbers of (pages, rows, columns) indexing an element in the three-dimensional array of shape [4,3,6].","category":"page"},{"location":"largrid/#Examples-1","page":"Cuboidal grids","title":"Examples","text":"","category":"section"},{"location":"largrid/#","page":"Cuboidal grids","title":"Cuboidal grids","text":"To understand the generation of cuboidal grids from products of 0- or 1-dimensional complexes, below we show a simple example of 2D grids embedded in R^3. In particular, v1 = [0 1 2 3] and v0 = [0 1 2] are two 2-arrays of 1D Points (i.e. with just one coordinate per vertex), c1 = [[0,1],[1,2],[2,3]] and c0 = [[0],[1],[2]] are the LAR representation of one 1-complex and one 0-complex, respectively. The solid 2-complex named grid2D is generated in 2D as follows, with reference to LinearAlgebraicRepresentation types:","category":"page"},{"location":"largrid/#","page":"Cuboidal grids","title":"Cuboidal grids","text":"julia> v1 = [0 1 2 3]::Lar.Points\n1√ó4 Array{Int64,2}:\n 0  1  2  3\n\njulia> c1 = [[0,1],[1,2],[2,3]]::Lar.Cells\n3-element Array{Array{Int64,1},1}:\n [0, 1]\n [1, 2]\n [2, 3]\n\njulia> grid2D = ( Lar.larVertProd([v1,v1]), Lar.larCellProd([c1,c1]) )::Lar.LAR\n([0 0 ‚Ä¶ 3 3; 0 1 ‚Ä¶ 2 3], Array{Int64,1}[[1, 2, 5, 6], [2, 3, 6, 7], [3, 4, 7, 8], [5, 6,\n9, 10], [6, 7, 10, 11], [7, 8, 11, 12], [9, 10, 13, 14], [10, 11, 14, 15], [11, 12, 15,\n16]])\n\njulia> grid2D[1]\n2√ó16 Array{Int64,2}:\n 0  0  0  0  1  1  1  1  2  2  2  2  3  3  3  3\n 0  1  2  3  0  1  2  3  0  1  2  3  0  1  2  3\n\njulia> grid2D[2]\n9-element Array{Array{Int64,1},1}:\n [1, 2, 5, 6]    \n [2, 3, 6, 7]    \n [3, 4, 7, 8]    \n [5, 6, 9, 10]   \n [6, 7, 10, 11]  \n [7, 8, 11, 12]  \n [9, 10, 13, 14] \n [10, 11, 14, 15]\n [11, 12, 15, 16]\n","category":"page"},{"location":"largrid/#Main-Interface-1","page":"Cuboidal grids","title":"Main Interface","text":"","category":"section"},{"location":"largrid/#","page":"Cuboidal grids","title":"Cuboidal grids","text":"Lar.larCellProd","category":"page"},{"location":"largrid/#LinearAlgebraicRepresentation.larCellProd","page":"Cuboidal grids","title":"LinearAlgebraicRepresentation.larCellProd","text":"larCellProd(cellLists::Array{Cells,1})::Cells\n\nGeneration of grid cells by Cartesian product of 0/1-complexes. The output complex is generated by the product of any number of either 0- or 1-dimensional cell complexes. The product of d 1-complexes generates solid d-cells, while the product of n 0-complexes and d-n 1-complexes (n  d) generates non-solid (d-n)-cells, properly embedded in d-space, i.e. with vertices having d coordinates.\n\nExamples\n\nTo understand the generation of cuboidal grids from products of 0- or 1-dimensional complexes, below we show a simple example of 2D grids embedded in R^3. In particular, v1 = [0. 1. 2. 3.] and v0 = [0. 1. 2.] are two 2-arrays of 1D vertices, c1 = [[0,1],[1,2],[2,3]] and c0 = [[0],[1],[2]] are the LAR representation of one 1-complex and one 0-complex, respectively. The solid 2-complex named grid2D is generated in 2D as follows:\n\njulia> v1 = [0. 1. 2. 3.]\n1√ó4 Array{Float64,2}:\n 0.0  1.0  2.0  3.0\n\njulia> c1 = [[0,1],[1,2],[2,3]]\n3-element Array{Array{Int64,1},1}:\n [0, 1]\n [1, 2]\n [2, 3]\n\njulia> grid2D = larVertProd([v1,v1]),larCellProd([c1,c1])\n([0.0 0.0 ‚Ä¶ 3.0 3.0; 0.0 1.0 ‚Ä¶ 2.0 3.0], Array{Int64,1}[[1, 2, 5, 6], [2, 3, 6, 7], [3, 4, 7, 8], [5, 6, 9, 10], [6, 7, 10, 11], [7, 8, 11, 12], [9, 10, 13, 14], [10, 11, 14, 15], [11, 12, 15, 16]])\n\nwhereas a non-solid 2-complex in 3D is generated as:\n\njulia> v1, c1 = [0. 1. 2. 3.],[[0,1],[1,2],[2,3]]\n([0.0 1.0 2.0 3.0], Array{Int64,1}[[0, 1], [1, 2], [2, 3]])\n\njulia> v0, c0 = [0. 1. 2.], [[0],[1],[2]]\n([0.0 1.0 2.0], Array{Int64,1}[[0], [1], [2]])\n\njulia> vertGrid = larVertProd([v1, v1, v0])\n3√ó48 Array{Float64,2}:\n 0.0  0.0  0.0  0.0  0.0  0.0  ‚Ä¶  3.0  3.0  3.0  3.0  3.0  3.0  3.0  3.0  3.0\n 0.0  0.0  0.0  1.0  1.0  1.0  ‚Ä¶  1.0  1.0  1.0  2.0  2.0  2.0  3.0  3.0  3.0\n 0.0  1.0  2.0  0.0  1.0  2.0  ‚Ä¶  0.0  1.0  2.0  0.0  1.0  2.0  0.0  1.0  2.0\n\njulia> cellGrid = larCellProd([c1, c1, c0])\n27-element Array{Array{Int64,1},1}:\n [1, 4, 13, 16]  \n [2, 5, 14, 17]  \n ...  ... ...\n [32, 35, 44, 47]\n [33, 36, 45, 48]\n\njulia> grid3D = vertGrid,cellGrid\n([0.0 0.0 ‚Ä¶ 3.0 3.0; 0.0 0.0 ‚Ä¶ 3.0 3.0; 0.0 1.0 ‚Ä¶ 1.0 2.0], Array{Int64,1}[[1, 4, 13, 16], [2, 5, 14, 17], ‚Ä¶ [32, 35, 44, 47], [33, 36, 45, 48]])\n\njulia> using Plasm\n\njulia> Plasm.view(grid3D)\n\n\n\n\n\n","category":"function"},{"location":"largrid/#","page":"Cuboidal grids","title":"Cuboidal grids","text":"Lar.larGridSkeleton","category":"page"},{"location":"largrid/#LinearAlgebraicRepresentation.larGridSkeleton","page":"Cuboidal grids","title":"LinearAlgebraicRepresentation.larGridSkeleton","text":"larGridSkeleton( shape::Array{Int,1} )( d::Int )::Cells\n\nProduce the d-dimensional skeleton (set of d-cells) of a cuboidal grid of given shape.\n\nExample\n\nA shape=[1,1,1] parameter refers to a grid with a single step on the three axes, i.e. to a single 3D unit cube. Below all skeletons of such simplest grid are generated.\n\njulia> Lar.larGridSkeleton([1,1,1])(0)\n# output\n8-element Array{Array{Int64,1},1}:\n[[1], [2], [3], [4], [5], [6], [7], [8]]\n\njulia> Lar.larGridSkeleton([1,1,1])(1)\n# output\n12-element Array{Array{Int64,1},1}:\n[[1,2],[3,4],[5,6],[7,8],[1,3],[2,4],[5,7],[6,8],[1,5],[2,6],[3,7],[4,8]]\n\njulia> Lar.larGridSkeleton([1,1,1])(2)\n# output\n6-element Array{Array{Int64,1},1}:\n[[1,2,3,4], [5,6,7,8], [1,2,5,6], [3,4,7,8], [1,3,5,7], [2,4,6,8]]\n\njulia> Lar.larGridSkeleton([1,1,1])(3)\n# output\n1-element Array{Array{Int64,1},1}:\n [1, 2, 3, 4, 5, 6, 7, 8]\n\n\n\n\n\n","category":"function"},{"location":"largrid/#","page":"Cuboidal grids","title":"Cuboidal grids","text":"Lar.larCuboids","category":"page"},{"location":"largrid/#LinearAlgebraicRepresentation.larCuboids","page":"Cuboidal grids","title":"LinearAlgebraicRepresentation.larCuboids","text":"larCuboids( shape, filled=false )::Union( Cells, Array{Cells,1} )\n\nMulti-dimensional generator function. Generate either a solid d-grid of unit d-cuboids in d-dimensional space, or the array of p-skeletons (0 =p= d), depending on the Boolean variable filled. 0-cuboids are points, 1-cuboids are segments, , 2-cuboids are squares,  3-cuboids are cubes, etc. The shape=[a,b,c] value determines the number a x b x c of d-cells. Notice that d = length(shape)\n\n\n\n\n\n","category":"function"},{"location":"largrid/#","page":"Cuboidal grids","title":"Cuboidal grids","text":"Lar.larModelProduct","category":"page"},{"location":"largrid/#LinearAlgebraicRepresentation.larModelProduct","page":"Cuboidal grids","title":"LinearAlgebraicRepresentation.larModelProduct","text":"larModelProduct\n\nThe larModelProduct function takes as input a pair of LAR models and returns the model of their Cartesian product. Since LAR type is a pair (geometrytopology), the second element of output is the topological product of the input topologies.\n\nExample\n\nData preparation follows.\n\njulia> geom_0,topol_0 = [0. 1. 2. 3. 4.],[[1],[2],[3],[4],[5]]\n([0.0 1.0 ‚Ä¶ 3.0 4.0], Array{Int64,1}[[1, 2], [2, 3], [3, 4], [4, 5]])\n\njulia> geom_1,topol_1 = [0. 1. 2.], [[1,2],[2,3]]\n([0.0 1.0 2.0], Array{Int64,1}[[1, 2], [2, 3]])\n\njulia> mod_0 = (geom_0,topol_0)\n([0.0 1.0 ‚Ä¶ 3.0 4.0], Array{Int64,1}[[1, 2], [2, 3], [3, 4], [4, 5]])\n\njulia> mod_1 = (geom_1,topol_1)\n([0.0 1.0 2.0], Array{Int64,1}[[1, 2], [2, 3]])\n\nGeneration of a 2D squares model, with 8 two-dimensional cells.\n\njulia> squares = larModelProduct(mod_1,mod_1)\n([0.0 0.0 ‚Ä¶ 4.0 4.0; 0.0 1.0 ‚Ä¶ 1.0 2.0], Array{Int64,1}[[1, 2, 4, 5], [2, 3, 5, 6], [4, 5, 7, 8], [5, 6, 8, 9], [7, 8, 10, 11], [8, 9, 11, 12], [10, 11, 13, 14], [11, 12, 14, 15]])\n\njulia> squares[1]\n2√ó15 Array{Float64,2}:\n 0.0  0.0  0.0  1.0  1.0  1.0  2.0  2.0  2.0  3.0  3.0  3.0  4.0  4.0  4.0\n 0.0  1.0  2.0  0.0  1.0  2.0  0.0  1.0  2.0  0.0  1.0  2.0  0.0  1.0  2.0\n\njulia> squares[2]\n8-element Array{Array{Int64,1},1}:\n[[1,2,4,5], [2,3,5,6], [4,5,7,8], [5,6,8,9], [7,8,10,11], [8,9,11,12], [10,11,13,14], [11,12,14,15]]\n\nGeneration of a 3D cubes model, with 32 three-dimensional cells.\n\njulia> cubes = larModelProduct(squares,mod_0)\n([0.0 0.0 ‚Ä¶ 4.0 4.0; 0.0 0.0 ‚Ä¶ 2.0 2.0; 0.0 1.0 ‚Ä¶ 3.0 4.0], Array{Int64,1}[[1, 2, 6, 7, 16, 17, 21, 22], [2, 3, 7, 8, 17, 18, 22, 23], [3, 4, 8, 9, 18, 19, 23, 24], [4, 5, 9, 10, 19, 20, 24, 25], ‚Ä¶ [53, 54, 58, 59, 68, 69, 73, 74], [54, 55, 59, 60, 69, 70, 74, 75]])\n\n\n\n\n\nlarModelProduct(twoModels::Array{LAR,1})::LAR\n\nFurther method associated to larModelProduct function.\n\n\n\n\n\n","category":"function"},{"location":"simplexn/#Simplicial-complexes-1","page":"Simplicial grids","title":"Simplicial complexes","text":"","category":"section"},{"location":"simplexn/#","page":"Simplicial grids","title":"Simplicial grids","text":"This module defines a minimal set of functions to generate a dimension-independent cellular complex of simplices. The name of the library was firstly used by  CAD Lab at University La Sapienza of Rome  in years 1987/88 when started working with dimension-independent simplicial complexes (see \"Dimension-independent modeling with simplicial complexes\" ). The library provides  combinatorial algorithms for some basic functions of geometric modelling with simplicial complexes. In particular, provides the efficient creation of simplicial complexes generated by simplicial complexes of lower dimension, the production of simplicial grids of any dimension, and the extraction of facets (i.e. of (d-1)-faces) of simplicial of d-complexes. The main aim of the simplicial functions given in this library is to provide optimal combinatorial algorithms, whose time complexity is linear in the size of the output. Such a goal is achieved by calculating each cell in the output via closed combinatorial formulas, that do not require any searching nor data structure traversal to produce their results.","category":"page"},{"location":"simplexn/#Simplicial-extrusion-1","page":"Simplicial grids","title":"Simplicial extrusion","text":"","category":"section"},{"location":"simplexn/#","page":"Simplicial grids","title":"Simplicial grids","text":"Here we discuss the implementation of the linear extrusion of simplicial complexes according to the method discussed on papers \"Dimension-independent modeling with simplicial complexes\" and \"Extrusion and boundary evaluation for multidimensional polyhedra\". In synthesis, for each d-simplex in the input complex, we generate combinatorially a (d+1)-simplicial tube, i.e. a chain of d+1 simplexes of dimension d+1. It can be shown that if the input simplices are a simplicial complex, then the output simplices are a simplicial complex too (i.e. are correctly glued together). ","category":"page"},{"location":"simplexn/#","page":"Simplicial grids","title":"Simplicial grids","text":"In other words, if the input is a dcomplex, where all d-cells either intersect along a common face or are pairwise disjoints, then the output is  a simplicial complex of dimension d+1. This method is computationally optimal, since it does not require any search or traversal of data structures. The algorithm just writes the output making a constant number O(1) of operation for each one of its n output d-cells, so that the time complexity is Omega(n), where n = dm, being m the number and d the dimension (and the storage size) of the input cells, represented as arrays of indices of vertices, using the Cells type.","category":"page"},{"location":"simplexn/#","page":"Simplicial grids","title":"Simplicial grids","text":"The aim of the extrudeSimplicial function is  to generate the output model vertices and cells in a multiple extrusion of a LAR model. First note that the model variable contains a pair (V, FV), where V is the array of input vertices, and FV is the array of d-cells (given as list of lists of vertex indices), providing the  input representation of a LAR cellular complex. The pattern variable is a list of integers, whose absolute values provide the sizes of the ordered set of 1D subintervals (in local coords) specified by the pattern itself. Such subintervals are assembled in global coordinates, and each one of them is considered either solid or empty depending on the sign of the corresponding measure, which may be either positive (solid subinterval) or negative (void subinterval).  ","category":"page"},{"location":"simplexn/#","page":"Simplicial grids","title":"Simplicial grids","text":"Therefore, a value pattern = [1,1,-1,1] is interpreted as the 1D simplicial complex","category":"page"},{"location":"simplexn/#","page":"Simplicial grids","title":"Simplicial grids","text":"[0,1] cup [1,2] cup [3,4]","category":"page"},{"location":"simplexn/#","page":"Simplicial grids","title":"Simplicial grids","text":"with five vertices W = [[0.0], [1.0], [2.0], [3.0], [4.0]] and three 1-cells [[0,1], [1,2], [3,4]].","category":"page"},{"location":"simplexn/#","page":"Simplicial grids","title":"Simplicial grids","text":"V is the list of input d-vertices (each given as a list of d coordinates); coords is a list of absolute translation parameters to be applied to V in order to generate the output vertices generated by the combinatorial extrusion algorithm. The cellGroups internal variable is used to select the groups of (d+1)-simplices corresponding to solid intervals in the input pattern.","category":"page"},{"location":"simplexn/#Simplicial-grids-1","page":"Simplicial grids","title":"Simplicial grids","text":"","category":"section"},{"location":"simplexn/#","page":"Simplicial grids","title":"Simplicial grids","text":"The generation of simplicial grids of any dimension and shape using the simplexGrid is amazingly simple. The input parameter shape is either a tuple or a list of integers used to specify the shape of the created array, i.e. both the number of its dimensions (given by len(shape)) and the size of each dimension k (given by the shape[k] element). The implementation starts from the LAR model of an empty simplicial  model (denoted as VOID, a predefined constant) and updates the model variable extruding it iteratively according to the specs given by shape. Just notice that the returned grid modelusually has vertices with integer coordinates, that can be subsequently scaled and/or translated and/or mapped in any other way, according to the user needs.","category":"page"},{"location":"simplexn/#Facet-extraction-from-simplices-1","page":"Simplicial grids","title":"Facet extraction from simplices","text":"","category":"section"},{"location":"simplexn/#","page":"Simplicial grids","title":"Simplicial grids","text":"A k-face of a d-simplex is defined as the convex hull of any subset of k vertices. A (d-1)-face of a d-simplex ","category":"page"},{"location":"simplexn/#","page":"Simplicial grids","title":"Simplicial grids","text":"sigma^d = langle v_0 v_1 ldots v_d rangle","category":"page"},{"location":"simplexn/#","page":"Simplicial grids","title":"Simplicial grids","text":"is also called a facet. Each of the d+1 facets of sigma^d, obtained by removing a vertex from sigma^d, is a (d-1)-simplex. A simplex may be oriented in two different ways according to the permutation class of its vertices. The simplex orientation is so changed by either multiplying the simplex by -1, or by executing an odd number of exchanges of its vertices. ","category":"page"},{"location":"simplexn/#","page":"Simplicial grids","title":"Simplicial grids","text":"The chain of oriented boundary facets of sigma^d, usually denoted as partial sigma^d, is generated combinatorially as follows:","category":"page"},{"location":"simplexn/#","page":"Simplicial grids","title":"Simplicial grids","text":"partial sigma^d = sum_k=0^d (-1)^d langle v_0 ldots v_k-1 v_k+1 ldots v_d rangle","category":"page"},{"location":"simplexn/#","page":"Simplicial grids","title":"Simplicial grids","text":"The larSimplexFacets function, for estraction of non-oriented (d-1)-facets of d-dimensional simplices, returns a list of d-tuples of integers, i.e. the input LAR representation of the topology of a cellular complex. The final steps are used to remove the duplicated facets, by transforming the sorted facets into a set of strings, so removing the duplicated elements.","category":"page"},{"location":"simplexn/#Examples-1","page":"Simplicial grids","title":"Examples","text":"","category":"section"},{"location":"simplexn/#Multidimensional-simplicial-extrusion-1","page":"Simplicial grids","title":"Multidimensional simplicial extrusion","text":"","category":"section"},{"location":"simplexn/#","page":"Simplicial grids","title":"Simplicial grids","text":"The algorithm for multimensional extrusion of a simplicial complex is implemented in the extrudeSimplicial function.  This one can be applied to 0-, 1-, 2-, ... simplicial model, to get a 1-, 2-, 3-, .... model.  A 1D pattern of linear Array type is used to specify how to decompose the added dimension.","category":"page"},{"location":"simplexn/#","page":"Simplicial grids","title":"Simplicial grids","text":"The input and output model are a LAR model, i.e. a pair (vertices, cells), whereas pattern is an array of Int64, to be used as lateral measures of the extruded model. Note that pattern elements are assumed as either solid or empty measures, according to their (+/-) sign.","category":"page"},{"location":"simplexn/#","page":"Simplicial grids","title":"Simplicial grids","text":"julia> Lar = LinearAlgebraicRepresentation\n\njulia> V = [[0,0] [1,0] [2,0] [0,1] [1,1] [2,1] [0,2] [1,2] [2,2]]\n2√ó9 Array{Int64,2}:\n 0  1  2  0  1  2  0  1  2\n 0  0  0  1  1  1  2  2  2\n\njulia> FV = [[1,2,4],[2,3,5],[3,5,6],[4,5,7],[5,7,8],[6,8,9]]\n6-element Array{Array{Int64,1},1}:\n [1, 2, 4]\n [2, 3, 5]\n [3, 5, 6]\n [4, 5, 7]\n [5, 7, 8]\n [6, 8, 9]\n\njulia> pattern = repeat([1,2,-3],outer=4)\n12-element Array{Int64,1}:\n[1,2,-3,1,2,-3,1,2,-3,1,2,-3]\n\njulia> model = (V,FV)\n([0 1 2 0 1 2 0 1 2; 0 0 0 1 1 1 2 2 2], \nArray{Int64,1}[[1, 2, 4], [2, 3, 5], [3, 5, 6], [4, 5, 7], [5, 7, 8], [6, 8, 9]])\n\njulia> W,FW = Lar.extrudeSimplicial(model, pattern)\n\njulia> W\n3√ó117 Array{Int64,2}:\n 0  1  2  0  1  2  0  1  2   ‚Ä¶   0   1   2   0   1   2   0   1   2   0   1   2\n 0  0  0  1  1  1  2  2  2       2   2   2   0   0   0   1   1   1   2   2   2\n 0  0  0  0  0  0  0  0  0      21  21  21  24  24  24  24  24  24  24  24  24\n\njulia> FW\n144-element Array{Array{Int64,1},1}:\n [1, 2, 4, 10]      \n [2, 4, 10, 11]     \n ‚ãÆ                  \n [96, 98, 99, 105]  \n [98, 99, 105, 107] \n [99, 105, 107, 108]\n\njulia> Plasm.view(W,FW)","category":"page"},{"location":"simplexn/#Multidimensional-grids-of-simplices-1","page":"Simplicial grids","title":"Multidimensional grids of simplices","text":"","category":"section"},{"location":"simplexn/#","page":"Simplicial grids","title":"Simplicial grids","text":"Generate a simplicial complex decomposition of a cubical grid of d-cuboids, where d is the length of shape=[n_1, n_2, ..., n_d] array, so that shape defines the grid dimension d and size n_1 times n_2 times  times n_d  as a d-dimensional array of cubes. Vertices (0-cells) of the grid have Int64 coordinates.","category":"page"},{"location":"simplexn/#","page":"Simplicial grids","title":"Simplicial grids","text":"julia> Lar.simplexGrid([0]) # 0-dimensional simplicial complex\n# output\n([0], Array{Int64,1}[])\n\njulia> V,EV = Lar.simplexGrid([1]) # 1-dimensional simplicial complex\n# output\n([0 1], Array{Int64,1}[[1, 2]])\n\njulia> V,FV = Lar.simplexGrid([1,1]) # 2-dimensional simplicial complex\n# output\n([0 1 0 1; 0 0 1 1], Array{Int64,1}[[1, 2, 3], [2, 3, 4]])\n\njulia> V,CV = Lar.simplexGrid([10,10,1]) # 3-dimensional simplicial complex\n# output\n([0 1 ‚Ä¶ 9 10; 0 0 ‚Ä¶ 10 10; 0 0 ‚Ä¶ 1 1], Array{Int64,1}[[1, 2, 12, 122], [2, 12, 122, 123], [12, 122, 123, 133], [2, 12, 13, 123], [12, 13, 123, 133], [13, 123, 133, 134], [2, 3, 13, 123], [3, 13, 123, 124], [13, 123, 124, 134], [3, 13, 14, 124]  ‚Ä¶  [119, 229, 230, 240], [109, 119, 120, 230], [119, 120, 230, 240], [120, 230, 240, 241], [109, 110, 120, 230], [110, 120, 230, 231], [120, 230, 231, 241], [110, 120, 121, 231], [120, 121, 231, 241], [121, 231, 241, 242]])\n\njulia> V\n# output\n3√ó242 Array{Int64,2}:\n 0  1  2  3  4  5  6  7  8  9  10  0  1  2  3  ‚Ä¶   1   2   3   4   5   6   7   8   9  10\n 0  0  0  0  0  0  0  0  0  0   0  1  1  1  1     10  10  10  10  10  10  10  10  10  10\n 0  0  0  0  0  0  0  0  0  0   0  0  0  0  0      1   1   1   1   1   1   1   1   1   1\n\n\njulia> using Plasm\n\njulia> hpc = Plasm.hpc_exploded(V,CV) # exploded visualization of the simplicial grid\n\njulia> Plasm.view(hpc)\n\njulia> V,HV = simplexGrid([1,1,1,1]) # 4-dim simplicial complex\n# output\n([0 1 ‚Ä¶ 0 1; 0 0 ‚Ä¶ 1 1; 0 0 ‚Ä¶ 1 1; 0 0 ‚Ä¶ 1 1], Array{Int64,1}[[1, 2, 3, 5, 9], [2, 3, 5, 9, 10], [3, 5, 9, 10, 11], [5, 9, 10, 11, 13], [2, 3, 5, 6, 10], [3, 5, 6, 10, 11], [5, 6, 10, 11, 13], [6, 10, 11, 13, 14], [3, 5, 6, 7, 11], [5, 6, 7, 11, 13]  ‚Ä¶  [4, 6, 10, 11, 12], [6, 10, 11, 12, 14], [3, 4, 6, 7, 11], [4, 6, 7, 11, 12], [6, 7, 11, 12, 14], [7, 11, 12, 14, 15], [4, 6, 7, 8, 12], [6, 7, 8, 12, 14], [7, 8, 12, 14, 15], [8, 12, 14, 15, 16]])","category":"page"},{"location":"simplexn/#Facets-of-multidimensional-simplicial-complexes-1","page":"Simplicial grids","title":"Facets of multidimensional simplicial complexes","text":"","category":"section"},{"location":"simplexn/#","page":"Simplicial grids","title":"Simplicial grids","text":"Compute the (d-1)-skeleton (set of facets) of a simplicial d-complex. Each of the d+1 facets of of a d-simplex sigma^d, obtained by removing a vertex from sigma^d, is a (d-1)-simplex.","category":"page"},{"location":"simplexn/#","page":"Simplicial grids","title":"Simplicial grids","text":"julia> V,FV = Lar.simplexGrid([1,1]) # 2-dimensional complex\n# output\n([0 1 0 1; 0 0 1 1], Array{Int64,1}[[1, 2, 3], [2, 3, 4]])\n\njulia> Plasm.view(V,FV)\n\njulia> W,CW = Lar.extrudeSimplicial((V,FV), [1])\n([0.0 1.0 ‚Ä¶ 0.0 1.0; 0.0 0.0 ‚Ä¶ 1.0 1.0; 0.0 0.0 ‚Ä¶ 1.0 1.0], \nArray{Int64,1}[[1,2,3,5],[2,3,5,6],[3,5,6,7],[2,3,4,6],[3,4,6,7],[4,6,7,8]])\n\njulia> FW = Lar.simplexFacets(CW)\n18-element Array{Any,1}:\n[[1,3,5],[5,6,7],[3,5,7],[3,6,7],[4,6,7],[4,7,8],[4,6,8],\n[6,7,8],[3,5,6],[2,3,5],[2,3,4],[3,4,7],[1,2,3],[2,4,6],[2,5,6],\n[1,2,5],[2,3,6],[3,4,6]]\n\njulia> Plasm.view(W,FW)","category":"page"},{"location":"simplexn/#Main-Interface-1","page":"Simplicial grids","title":"Main Interface","text":"","category":"section"},{"location":"simplexn/#","page":"Simplicial grids","title":"Simplicial grids","text":"Lar.simplexGrid","category":"page"},{"location":"simplexn/#LinearAlgebraicRepresentation.simplexGrid","page":"Simplicial grids","title":"LinearAlgebraicRepresentation.simplexGrid","text":"simplexGrid(shape::Array)::LAR\n\nGenerate a simplicial complex decomposition of a cubical grid of d-cuboids, where d is the length of shape array. Vertices (0-cells) of the grid have Int64 coordinates.\n\nExamples\n\njulia> simplexGrid([0]) # 0-dimensional complex\n# output\n([0], Array{Int64,1}[])\n\njulia> V,EV = simplexGrid([1]) # 1-dimensional complex\n# output\n([0 1], Array{Int64,1}[[1, 2]])\n\njulia> V,FV = simplexGrid([1,1]) # 2-dimensional complex\n# output\n([0 1 0 1; 0 0 1 1], Array{Int64,1}[[1, 2, 3], [2, 3, 4]])\n\njulia> V,CV = simplexGrid([10,10,1]) # 3-dimensional complex\n# output\n([0 1 ‚Ä¶ 9 10; 0 0 ‚Ä¶ 10 10; 0 0 ‚Ä¶ 1 1], Array{Int64,1}[[1, 2, 12, 122], [2, 12, 122, 123], [12, 122, 123, 133], [2, 12, 13, 123], [12, 13, 123, 133], [13, 123, 133, 134], [2, 3, 13, 123], [3, 13, 123, 124], [13, 123, 124, 134], [3, 13, 14, 124]  ‚Ä¶  [119, 229, 230, 240], [109, 119, 120, 230], [119, 120, 230, 240], [120, 230, 240, 241], [109, 110, 120, 230], [110, 120, 230, 231], [120, 230, 231, 241], [110, 120, 121, 231], [120, 121, 231, 241], [121, 231, 241, 242]])\n\njulia> V\n# output\n3√ó242 Array{Int64,2}:\n 0  1  2  3  4  5  6  7  8  9  10  0  1  2  3  ‚Ä¶   1   2   3   4   5   6   7   8   9  10\n 0  0  0  0  0  0  0  0  0  0   0  1  1  1  1     10  10  10  10  10  10  10  10  10  10\n 0  0  0  0  0  0  0  0  0  0   0  0  0  0  0      1   1   1   1   1   1   1   1   1   1\n\njulia> using Plasm\n\njulia> hpc = Plasm.lar2exploded_hpc(V,CV) # exploded visualization of the grid\n\njulia> Plasm.view(hpc)\n\njulia> V,HV = simplexGrid([1,1,1,1]) # 4-dim cellular complex from the 4D simplex\n# output\n([0 1 ‚Ä¶ 0 1; 0 0 ‚Ä¶ 1 1; 0 0 ‚Ä¶ 1 1; 0 0 ‚Ä¶ 1 1], Array{Int64,1}[[1, 2, 3, 5, 9], [2, 3, 5, 9, 10], [3, 5, 9, 10, 11], [5, 9, 10, 11, 13], [2, 3, 5, 6, 10], [3, 5, 6, 10, 11], [5, 6, 10, 11, 13], [6, 10, 11, 13, 14], [3, 5, 6, 7, 11], [5, 6, 7, 11, 13]  ‚Ä¶  [4, 6, 10, 11, 12], [6, 10, 11, 12, 14], [3, 4, 6, 7, 11], [4, 6, 7, 11, 12], [6, 7, 11, 12, 14], [7, 11, 12, 14, 15], [4, 6, 7, 8, 12], [6, 7, 8, 12, 14], [7, 8, 12, 14, 15], [8, 12, 14, 15, 16]])\n\n\n\n\n\n","category":"function"},{"location":"simplexn/#","page":"Simplicial grids","title":"Simplicial grids","text":"Lar.simplexFacets","category":"page"},{"location":"simplexn/#LinearAlgebraicRepresentation.simplexFacets","page":"Simplicial grids","title":"LinearAlgebraicRepresentation.simplexFacets","text":"simplexFacets(simplices::Cells)::Cells\n\nCompute the (d-1)-skeleton (unoriented set of facets) of a simplicial d-complex.\n\nExample\n\njulia> V,FV = Lar.simplexGrid([1,1]) # 2-dimensional complex\n# output\n([0 1 0 1; 0 0 1 1], Array{Int64,1}[[1, 2, 3], [2, 3, 4]])\n\njulia> Plasm.view(V,FV)\n\njulia> W,CW = Lar.extrudeSimplicial((V,FV), [1])\n([0.0 1.0 ‚Ä¶ 0.0 1.0; 0.0 0.0 ‚Ä¶ 1.0 1.0; 0.0 0.0 ‚Ä¶ 1.0 1.0], \nArray{Int64,1}[[1,2,3,5],[2,3,5,6],[3,5,6,7],[2,3,4,6],[3,4,6,7],[4,6,7,8]])\n\njulia> FW = Lar.simplexFacets(CW)\n18-element Array{Any,1}:\n[[1,3,5],[5,6,7],[3,5,7],[3,6,7],[4,6,7],[4,7,8],[4,6,8],\n[6,7,8],[3,5,6],[2,3,5],[2,3,4],[3,4,7],[1,2,3],[2,4,6],[2,5,6],\n[1,2,5],[2,3,6],[3,4,6]]\n\njulia> Plasm.view(W,FW)\n\nExample\n\njulia> V,(VV,EV,FV,CV) = Lar.cuboidGrid([3,3,3],true)\n\njulia> TV = Lar.simplexFacets(CV)\n\njulia> Plasm.view(V,TV)\n\n\n\n\n\n\n","category":"function"},{"location":"simplexn/#","page":"Simplicial grids","title":"Simplicial grids","text":"Lar.extrudeSimplicial","category":"page"},{"location":"simplexn/#LinearAlgebraicRepresentation.extrudeSimplicial","page":"Simplicial grids","title":"LinearAlgebraicRepresentation.extrudeSimplicial","text":"extrudeSimplicial(model::LAR, pattern::Array)::LAR\n\nAlgorithm for multimensional extrusion of a simplicial complex.  Can be applied to 0-, 1-, 2-, ... simplicial models, to get a 1-, 2-, 3-, .... model. The pattern Array is used to specify how to decompose the added dimension.\n\nA model is a LAR model, i.e. a pair (vertices,cells) to be extruded, whereas pattern is an array of Int64, to be used as lateral measures of the extruded model. pattern elements are assumed as either solid or empty measures, according to their (+/-) sign.\n\nExample\n\njulia> V = [[0,0] [1,0] [2,0] [0,1] [1,1] [2,1] [0,2] [1,2] [2,2]];\n\njulia> FV = [[1,2,4],[2,3,5],[3,5,6],[4,5,7],[5,7,8],[6,8,9]];\n\njulia> pattern = repeat([1,2,-3],outer=4);\n\njulia> model = (V,FV);\n\njulia> W,FW = extrudeSimplicial(model, pattern);\n\njulia> Plasm.view(W,FW)\n\n\n\n\n\n","category":"function"},{"location":"integr/#Finite-integration-of-polynomials-1","page":"Domain integration","title":"Finite integration of polynomials","text":"","category":"section"},{"location":"integr/#","page":"Domain integration","title":"Domain integration","text":"A finite integration method, from \"Boundary integration over linear polyhedra\", is developed here, to compute various-order monomial integrals over polyhedral solids and surfaces in 3D space. The integration method can be used for the exact evaluation of domain integrals of trivariate polynomial forms.","category":"page"},{"location":"integr/#Integration-Algorithms-1","page":"Domain integration","title":"Integration Algorithms","text":"","category":"section"},{"location":"integr/#","page":"Domain integration","title":"Domain integration","text":"Here we implement a finite solution to both surface and volume integration of polynomials, by using a triangulation of the domain boundary.   The evaluation of surface and volume integrals is achieved by transformation into line integrals over the boundary of every 2-simplex of a domain triangulation.  A different approach to finite integration, using a decomposition into volume elements induced by a boundary triangulation is given in \"A symbolic method for calculating the integral properties of arbitrary nonconvex polyhedra\" where a closed formula for volume integration over polyhedral volumes, by decomposing the solid into a set of solid tetrahedra, but such a method cannot be used for surface integrations.","category":"page"},{"location":"integr/#","page":"Domain integration","title":"Domain integration","text":"Surface integrals are computed as a summation of integrals over a  triangulation of the surface.  Any triangle is mapped into the unit  triangle in the 2-space of parameters, where integrals  of monomials become particularly  simple.  Then formulae for integrals over polyhedral volumes are  given.  They are easily derived by transforming volume integrals in  surface integrals using the Divergence Theorem.   It is possible to show that such integrals are  computable in polynomial time, and that inertia moments are computable  in O(E) time, E being the number of edges of the solid model of  the integration domain.","category":"page"},{"location":"integr/#","page":"Domain integration","title":"Domain integration","text":"An important feature of the integration formulae presented here is that they can also be used with a partial model of a polyhedron, consisting of the collection of its boundary's 2-cell cycles (loops).   Loops are oriented counter-clockwise if external, clockwise if internal to another loop.  Such a  model, without explicit storage of face adjacencies, is very frequently adopted in Computer Graphics. In this case it is sufficient to consider any (n+1)-sided face (also unconnected or multiply connected)  as topological sum of n-1 oriented triangles t_i, with vertices langle v_0 v_i v_i+1rangle, where 1le ile n-1 .  In applying formulae (\\ref{19}) or (\\ref{27}) to such a set of triangles, any edge that does not belong to the original polygon will be computed twice, in the two opposite directions.  These contributions to the whole integral will mutually cancel each other, as they correspond to pairs of line integrals evaluated along opposite paths","category":"page"},{"location":"integr/#Examples-1","page":"Domain integration","title":"Examples","text":"","category":"section"},{"location":"integr/#D-integration-1","page":"Domain integration","title":"2D integration","text":"","category":"section"},{"location":"integr/#","page":"Domain integration","title":"Domain integration","text":"First some examples are given of the basic integration functions on 2D plane. The II integral, with parameters alpha,beta,gamma = 0,0,0 returns the area of the domain P. It is important to notice that all domains (both 2D and 3D) are embedded in 3-space.","category":"page"},{"location":"integr/#Example-unit-3D-triangle-1","page":"Domain integration","title":"Example  unit 3D triangle","text":"","category":"section"},{"location":"integr/#","page":"Domain integration","title":"Domain integration","text":"julia> V = [0.0 1.0 0.0; 0.0 0.0 1.0; 0.0 0.0 0.0]\n3√ó3 Array{Float64,2}:\n 0.0  1.0  0.0\n 0.0  0.0  1.0\n 0.0  0.0  0.0\n\njulia> FV = [[1,2,3]]\n1-element Array{Array{Int64,1},1}:\n [1, 2, 3]\n\njulia> P = V,FV\n([0.0 1.0 0.0; 0.0 0.0 1.0; 0.0 0.0 0.0], Array{Int64,1}[[1, 2, 3]])\n\njulia> Lar.II(P, 0,0,0)\n0.5","category":"page"},{"location":"integr/#","page":"Domain integration","title":"Domain integration","text":"Then, more interesting examples are given. First, the surface of the affinely transformed (rotated and translated) unit square:","category":"page"},{"location":"integr/#","page":"Domain integration","title":"Domain integration","text":"julia> V,FV = Lar.simplexGrid([1,1])\n([0.0 1.0 0.0 1.0; 0.0 0.0 1.0 1.0], Array{Int64,1}[[1, 2, 3], [2, 3, 4]])\n\njulia> P = [V;[0 0 0 0]], FV\n([0.0 1.0 0.0 1.0; 0.0 0.0 1.0 1.0; 0.0 0.0 0.0 0.0], \nArray{Int64,1}[[1, 2, 3], [2, 3, 4]])\n\njulia> Lar.surface(P)\n1.0\n\njulia> p = Lar.Struct([Lar.t(0.5,0.5,0), Lar.r(0,0,pi/4), P]);\n\njulia> q = Lar.struct2lar(p);\n\njulia> Lar.surface(q)\n1.0000000532124802","category":"page"},{"location":"integr/#","page":"Domain integration","title":"Domain integration","text":"Then, the surface and the barycenter  of the simplicial grid 3 x 4 of unit 2-cells on the z=0 plane is computed. Notice that the  centroid function cannot be used, since P is two-dimensional (flat) and embedded in 3-space. So, we use directly the centroid definition as first surface moments divided by area. Remember that the grid domain is 3 x 4.","category":"page"},{"location":"integr/#","page":"Domain integration","title":"Domain integration","text":"julia> V,FV = Lar.simplexGrid([3,4]);\n\njulia> P = [V; zeros(size(V,2))'], FV;\n\njulia> Lar.surface(P)\n12.0\n\njulia> Lar.II(P,1,0,0)/Lar.II(P,0,0,0)\n1.5\n\njulia> Lar.II(P,0,1,0)/Lar.II(P,0,0,0)\n2.0\n\njulia> Lar.II(P,0,0,1)/Lar.II(P,0,0,0)\n0.0","category":"page"},{"location":"integr/#D-integration-2","page":"Domain integration","title":"3D integration","text":"","category":"section"},{"location":"integr/#","page":"Domain integration","title":"Domain integration","text":"The simplest example of volume integration is volume integral on the unit 3D tetrahedron P.","category":"page"},{"location":"integr/#","page":"Domain integration","title":"Domain integration","text":"julia> V = [0.0 1.0 0.0 0.0; 0.0 0.0 1.0 0.0; 0.0 0.0 0.0 1.0]\n3√ó4 Array{Float64,2}:\n 0.0  1.0  0.0  0.0\n 0.0  0.0  1.0  0.0\n 0.0  0.0  0.0  1.0\n\njulia> FV = [[1, 2, 4], [1, 3, 2], [4, 3, 1], [2, 3, 4]]\n4-element Array{Array{Int64,1},1}:\n [1, 2, 4]\n [1, 3, 2]\n [4, 3, 1]\n [2, 3, 4]\n\njulia> P = V,FV\n([0.0 1.0 0.0 0.0; 0.0 0.0 1.0 0.0; 0.0 0.0 0.0 1.0], \nArray{Int64,1}[[1, 2, 4], [1, 3, 2], [4, 3, 1], [2, 3, 4]])\n\njulia> Lar.volume(P)\n0.16666666666666674","category":"page"},{"location":"integr/#","page":"Domain integration","title":"Domain integration","text":"For more general polyhedrons, we must extract the boundary sourface, get a triangulation and apply the 3D integration functions on the LAR of such models.","category":"page"},{"location":"integr/#Main-Interface-1","page":"Domain integration","title":"Main Interface","text":"","category":"section"},{"location":"integr/#","page":"Domain integration","title":"Domain integration","text":"Lar.surface","category":"page"},{"location":"integr/#LinearAlgebraicRepresentation.surface","page":"Domain integration","title":"LinearAlgebraicRepresentation.surface","text":"sphere(radius=1., angle1=pi, angle2=2*pi)(shape=[18, 36])\n\nCompute a cellular 2-complex, approximation of the two-dimensional closed surface, embedded in a three-dimensional Euclidean space. Geographical coordinates are user to compute the 0-cells of the complex.\n\nExample\n\njulia> using Plasm\n\njulia> Plasm.view(Lar.sphere()())\n\n\n\n\n\n","category":"type"},{"location":"integr/#","page":"Domain integration","title":"Domain integration","text":"Lar.volume","category":"page"},{"location":"integr/#LinearAlgebraicRepresentation.volume","page":"Domain integration","title":"LinearAlgebraicRepresentation.volume","text":"volume(P::Lar.LAR)::Float64\n\nvolume integral on polyhedron P.\n\nExample # unit 3D tetrahedron\n\njulia> V = [0.0 1.0 0.0 0.0; 0.0 0.0 1.0 0.0; 0.0 0.0 0.0 1.0]\n3√ó4 Array{Float64,2}:\n 0.0  1.0  0.0  0.0\n 0.0  0.0  1.0  0.0\n 0.0  0.0  0.0  1.0\n\njulia> FV = [[1, 2, 4], [1, 3, 2], [4, 3, 1], [2, 3, 4]]\n4-element Array{Array{Int64,1},1}:\n [1, 2, 4]\n [1, 3, 2]\n [4, 3, 1]\n [2, 3, 4]\n\njulia> P = V,FV\n([0.0 1.0 0.0 0.0; 0.0 0.0 1.0 0.0; 0.0 0.0 0.0 1.0], \nArray{Int64,1}[[1, 2, 4], [1, 3, 2], [4, 3, 1], [2, 3, 4]])\n\njulia> Lar.volume(P)\n0.16666666666666674\n\n\n\n\n\n","category":"function"},{"location":"integr/#","page":"Domain integration","title":"Domain integration","text":"Lar.centroid","category":"page"},{"location":"integr/#LinearAlgebraicRepresentation.centroid","page":"Domain integration","title":"LinearAlgebraicRepresentation.centroid","text":"centroid(P::Lar.LAR)::Array{Float64,1}\n\nBarycenter or centroid of polyhedron P.\n\nExample # unit 3D tetrahedron\n\njulia> V = [0.0 1.0 0.0 0.0; 0.0 0.0 1.0 0.0; 0.0 0.0 0.0 1.0];\n\njulia> FV = [[1, 2, 4], [1, 3, 2], [4, 3, 1], [2, 3, 4]];\n\njulia> P = V,FV;\n\njulia> Lar.centroid(P)\n3-element Array{Float64,1}:\n 0.25\n 0.25\n 0.25\n\n\n\n\n\n","category":"function"}]
}
