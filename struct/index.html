<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Assemblies · LinearAlgebraicRepresentation.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/lar.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="LinearAlgebraicRepresentation.jl logo"/></a><h1>LinearAlgebraicRepresentation.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../lar/">L.A.R. Intro</a></li><li><a class="toctext" href="../interface/">Interface</a></li><li><a class="toctext" href="../arrangement/">Arrangement</a></li><li><span class="toctext">Parametric primitives</span><ul><li><a class="toctext" href="../mapper/">Mapper</a></li><li class="current"><a class="toctext" href>Assemblies</a><ul class="internal"><li><a class="toctext" href="#Hierarchical-graphs-1">Hierarchical graphs</a></li><li><a class="toctext" href="#Hierarchical-structures-1">Hierarchical structures</a></li><li><a class="toctext" href="#Examples-1">Examples</a></li><li><a class="toctext" href="#Main-Interface-1">Main Interface</a></li></ul></li></ul></li><li><span class="toctext">Grid generation</span><ul><li><a class="toctext" href="../largrid/">Cuboidal grids</a></li><li><a class="toctext" href="../simplexn/">Simplicial grids</a></li></ul></li><li><a class="toctext" href="../integr/">Domain integration</a></li></ul></nav><article id="docs"><header><nav><ul><li>Parametric primitives</li><li><a href>Assemblies</a></li></ul><a class="edit-page" href="https://github.com//blob/master/Downloads/LinearAlgebraicRepresentation.jl/docs/src/struct.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Assemblies</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Assemblies-of-cellular-complexes-1" href="#Assemblies-of-cellular-complexes-1">Assemblies of cellular complexes</a></h1><p>Hierarchical models of complex assemblies are generated by aggregation of cellular complexes, each one defined in a local coordinate system, and possibly relocated by affine transformations of coordinates.  This operation may be repeated hierarchically, with subassemblies defined by aggregation of simpler parts, and so on, until to obtain a set of LAR models, which are not further decomposed.</p><p><img src="../images/refectory.png" alt/></p><blockquote><p><strong>Figure 1:</strong> Hierarchical assembly of cellular 3-complexes.</p></blockquote><p>Two main advantages can be found in a hierarchical modeling approach. Each component complex  and each assembly, at every hierarchical level, are defined independently from each other, using a local coordinate frame, suitably chosen to make its definition easier. Furthermore, only one copy of each component is stored in memory, and may be instanced in different locations and orientations how many times it is needed.</p><p><img src="../images/struct-ab.png" alt/></p><blockquote><p><strong>Figure 2:</strong> Hierarchical assembly of a 2-complex consisting of a single 2-cell (the square): (a) 2-skeleton; (b) 1-skeleton of the resulting complex.</p></blockquote><h2><a class="nav-anchor" id="Hierarchical-graphs-1" href="#Hierarchical-graphs-1">Hierarchical graphs</a></h2><p>A <a href="#structure">hierarchical model</a>, defined inductively as an assembly of component parts, is described by an <em>acyclic directed multigraph</em>, often called a <em>scene graph</em> or <em>hierarchical structure</em> in computer graphics and modeling.  The main algorithm with hierarchical assemblies is the <em>traversal</em> function, which transforms every component from <em>local coordinates</em> to global coordinates, called <em>world coordinates</em>.</p><h3><a class="nav-anchor" id="Acyclic-directed-multigraph-1" href="#Acyclic-directed-multigraph-1">Acyclic directed-multigraph</a></h3><p>The standard definition of a <em>directed graph</em> <span>$G$</span> states that it is a pair <span>$(N,A)$</span>, where <span>$N$</span> is a set of <em>nodes</em> and <span>$A$</span> is a set of directed <em>arcs</em>, given as ordered pairs of nodes.  Such a definition is not sufficient when more than one arc must be considered between the same pair of nodes.</p><p>In this case the notion of <em>multigraph</em> is introduced.  A <em>directed multigraph</em> is a triplet <span>$G := (N,A,f)$</span> where <span>$N$</span> and <span>$A$</span> are sets of nodes and arcs, respectively, and <span>$f: A \to \mathbf{N}^{2}$</span> is a mapping from arcs to node pairs.  In other words, in a multigraph, the same pair of nodes can be connected by multiple arcs.</p><p>Directed graphs or multigraphs are said to be <em>acyclic</em> when they do not contain cycles, i.e. when no path starts and ends at the same vertex.  <em>Trees</em> are common examples of acyclic graphs. A tree, where each non-leaf node is the root of a subtree, is the best model of the concept of <em>hierarchy</em>. Nodes in a tree can be associated with their integer <em>distance</em> from the root, defined by the number of edges on the unique path from the root to the node.  A tree can be layered by <em>levels</em>, by putting in the same subset (level) all the nodes with equal distance from the root.  </p><p>Acyclic graphs/multigraphs are also called <em>hierarchical graphs</em>, because they can be associated to a tree, generated at run-time by visiting the graph with some standard traversal algorithm, e.g. with a depth-first-search.  The ordered sequence of nodes produced by the traversal is sometimes called a <em>linearized graph</em>.  Each node in this sequence is suitably transformed from local coordinates to <em>world coordinates</em>, i.e. to the coordinates of the root, by the traversal algorithm.</p><h2><a class="nav-anchor" id="Hierarchical-structures-1" href="#Hierarchical-structures-1">Hierarchical structures</a></h2><p>Various kinds of hierarchical assemblies are used in standard graphical systems, such as <em>GKS</em>, <em>PHIGS</em> and <em>VRML</em>, as well as in graphics libraries like <em>Open Inventor</em> and <em>Java 3D</em>.  The <code>type</code> of hierarchical structures adopted here is inspired, even in the name of the function used for this purpose, by the one introduced by <em>PHIGS</em>, i.e. <code>Struct</code>.</p><p>The arcs of scene graphs are normally specified <em>implicitly</em> in real graphical systems. For example, an arc is actually specified when a node is contained or referred within another one. In particular, it is possible to specify a new container node together with either the matrix or the parameters of the transformation to be associated with the the arc that connects the new container to the current node.</p><h2><a class="nav-anchor" id="Examples-1" href="#Examples-1">Examples</a></h2><h3><a class="nav-anchor" id="Containers-of-geometric-objects-1" href="#Containers-of-geometric-objects-1">Containers of geometric objects</a></h3><pre><code class="language-julia">type Struct
	body::Array
	box
	name::AbstractString
	dim
	category::AbstractString
end</code></pre><p>where <code>body::Array</code> is the <em>actual container</em>, which may contain geometric models, affine transformations, and other structure values; <code>box</code> is a representation of the <em>containment box</em>; <code>name</code> is an identifier, initialized to the <code>id</code> of the empty object created by the constructor <code>Struct()</code>; <code>dim</code> is the dimension of the embedding space, i.e. the number of coordinates; <code>category</code> is a property of the created value, initializated to &quot;feature&quot;.</p><p>A typical LAR geometrical model is a <code>Tuple</code> (triple or pair), where the first element is the <em>matrix of coordinates</em> of vertices, and the remaining arrays of array of integers provide the <em>vertex indices</em> of each <em>cell</em>. </p><pre><code class="language-julia">julia&gt; square = ([[0; 0] [0; 1] [1; 0] [1; 1]], [[1, 2, 3,
4]], [[1,2], [1,3], [2,4], [3,4]])
# output
([0 0 1 1; 0 1 0 1], Array{Int64,1}[[1, 2, 3, 4]], Array{Int64,1}[[1, 2], [1,
3], [2, 4], [3, 4]]) </code></pre><p>A <em>container</em> of geometrical objects is defined by applying the function <code>Struct</code> to the array of contained objects.  The value returned from the application is a value of  <em>Struct</em> type.  The coordinate system of this value is the one associated with the first object of the <code>Struct</code> parameters.  Also, the resulting geometrical value is often associated with a variable name.</p><h3><a class="nav-anchor" id="Affine-transformations-and-containers-1" href="#Affine-transformations-and-containers-1">Affine transformations and containers</a></h3><p>Affine transformations or tensor matrices, of type <code>Arra{Float64, 2}</code>, are created by functions</p><pre><code class="language-none">Lar.t(args...)	# for translation
Lar.s(args...)	# for scaling
Lar.r(args...)	# for rotation</code></pre><p>An affine <span>$3\times 3$</span> transformation matrix, generated in homogeneous normalized coordinates by the function call <code>t(-0.5,-0.5)</code>, can be <em>applied</em> to a LAR object <code>obj</code> both <em>explicitly</em> by using the function <code>apply(Matrix, obj)</code> or <em>implicitly</em> by creating a <code>Struct</code> hierarchical object, as shown by the following examples:</p><pre><code class="language-julia">julia&gt; Lar = LinearAlgebraicRepresentation

julia&gt; table = Lar.apply( Lar.t(-0.5,-0.5), square )
# output
([-0.5 -0.5 0.5 0.5; -0.5 0.5 -0.5 0.5], Array{Int64,1}[[1, 2, 3, 4]],
Array{Int64,1}[[1, 2], [1, 3], [2, 4], [3, 4]])

julia&gt; table = Lar.Struct([ Lar.t(-0.5,-0.5), square ])
# output
Struct(Any[[1.0 0.0 -0.5; 0.0 1.0 -0.5; 0.0 0.0 1.0], ([0 0 1 1; 0 1 0 1],
Array{Int64,1}[[1, 2, 3, 4]], Array{Int64,1}[[1, 2], [1, 3], [2, 4], [3, 4]])],
Array[[-0.5; -0.5], [0.5; 0.5]], &quot;10234090646332247690&quot;, 2, &quot;feature&quot;) </code></pre><p>The generation of container nodes may continue hierarchically by suitably applying <code>Struct</code>. Notice that each LAR object in a <code>Struct</code> container is transformed by each matrix before it <em>within the container</em>, going from right to left. The action of a transformation (tensor) extends to each object on its right within its own container. Whereas,  the action of a tensor does not extend outside its container, according to the semantics of <em>PHIGS</em> structures.</p><pre><code class="language-julia">chair = Lar.Struct([ Lar.t(0.75,0), Lar.s(0.35,0.35), table ])</code></pre><h3><a class="nav-anchor" id="Container-evaluation-1" href="#Container-evaluation-1">Container evaluation</a></h3><p>The function <code>evalStruct</code>, when applied to a <code>Struct</code> value, generates an <code>Array</code> of LAR models, each one originally defined  in a <em>local coordinate</em> system, transforming all of them in the same <em>world coordinate</em>, equal to the ones of the <em>first</em> object in the <code>Struct</code> parameter sequence.</p><p>Conversely, the <code>struct2lar</code> function generates a <em>single</em> LAR model (cellular complex), whose components are here assigned respectively to variables <code>W</code> (coordinates of vertices), <code>FW</code> faces (2-cells), and <code>EW</code> edges (1-cells). Notice that the whole model is <em>embedded in 2D</em>, since the <code>W</code> array (coordinates by columns) has <em>two rows</em></p><pre><code class="language-julia">scene = Lar.evalStruct(struct02)	# array of LAR models
W,FW,EW = Lar.struct2lar(struct02)	# single LAR model</code></pre><h3><a class="nav-anchor" id="Simple-assembly-examples-1" href="#Simple-assembly-examples-1">Simple assembly examples</a></h3><p>The object <code>struct0</code> below contains a table and 4 chairs, <code>struct01</code> is a row of 10 suitably translated instances of <code>struct0</code>, and <code>struct02</code> is another assembly of suitably translated <code>struct01</code> instances. </p><pre><code class="language-julia">L = LinearAlgebraicRepresentation
struct0 = L.Struct([ L.t(2,1),table, repeat([L.r(pi/2), chair ], outer = 4)... ])
struct01 = L.struct2lar(L.Struct( repeat([ struct0, L.t(0,2.5) ], outer = 10) ));
scene = L.struct2lar(L.Struct( repeat([ struct01, L.t(3,0) ], outer = 10) ));</code></pre><p>To see the generated 2D scene you need the <code>Plasm</code> module.</p><pre><code class="language-julia">using Plasm
Plasm.view(scene[1],scene[2])
Plasm.view(scene[1],scene[3])</code></pre><p>A different example provides a <code>sphere</code>, and a <code>cylinder</code> instance suitably translated, within the same <code>Struct</code> container. Of course, we could define a hierarchical assembly of any size and deep, containing any number of <code>Struct</code> nodes.</p><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p>2D surfaces embedded in 3D are normally displayed in <code>Plasm</code> as made of unoriented 2-cells. In order to get a better dispaly, the user should press the <code>t</code> or <code>T</code> keys on the keyboard.</p></div></div><pre><code class="language-julia">assembly = L.Struct([L.sphere()(), L.t(3,0,-1), L.cylinder()()])
using Plasm
Plasm.view(L.struct2lar(assembly))</code></pre><p><img src="../images/struct-cd.png" alt/></p><blockquote><p><strong>Figure 3:</strong> (a) Enlargement of a portion of the exploded complex in Fig.1; (b) an assembly with two cuboidal 2-complexes (surfaces) embedded in 3D.</p></blockquote><h3><a class="nav-anchor" id="Coding-of-3D-refectory-assembly-1" href="#Coding-of-3D-refectory-assembly-1">Coding of 3D <code>refectory</code> assembly</a></h3><p>The <code>refectory</code> model shown in Figure 1 is stepwise developed here. Of course, in order to display the various <em>geometric models</em>, the <code>Plasm</code> package is needed.</p><pre><code class="language-julia">using LinearAlgebraicRepresentation
L = LinearAlgebraicRepresentation

using Plasm
View = Plasm.view</code></pre><p><img src="../images/parts.png" alt/></p><blockquote><p><strong>Figure 4:</strong> The generation process of the <code>refectory</code> assembly shown in Figure 1.</p></blockquote><p>First develop the <code>table</code> model, starting from a single <code>cube</code> object, of type <code>LAR = Tuple{Points,Cells}</code>, suitably translated to get the base center at the origin, then create containers for <code>tableTop</code>, <code>tablelegs</code>, and <code>table</code>. Finally <em>check the assembly</em> correctness, and convert to a <code>LAR</code> value.  The <code>View</code> primitive may be applied both to  <code>Struct</code> and <code>LAR</code> values, as well to other types.</p><pre><code class="language-julia">cube = L.apply( L.t(-.5,-.5,0), L.cuboid([1,1,1]))
tableTop = L.Struct([ L.t(0,0,.85), L.s(1,1,.05), cube ])
tableLeg = L.Struct([ L.t(-.475,-.475,0), L.s(.1,.1,.89), cube ])
tablelegs = L.Struct( repeat([ tableLeg, L.r(0,0,pi/2) ],outer=4) )
table = L.Struct([ tableTop, tablelegs ])
View(table)
table = L.struct2lar(table)
View(table)</code></pre><p>Then build the <code>chair</code> model as above. The polyhedral <code>cylndr</code> is defined with 8 lateral faces, and 16 vertices. </p><pre><code class="language-julia">cylndr = L.rod(.06, .5, 2*pi)([8,1])
chairTop = L.Struct([ L.t(0,0,0.5), L.s(0.5,0.5,0.04), cube ])
chairLeg = L.Struct([ L.t(-.22,-.22,0), L.s(.5,.5,1), L.r(0,0,pi/8), cylndr ])
chairlegs = L.Struct( repeat([ chairLeg, L.r(0,0,pi/2) ],outer=4) );
chair = L.Struct([ chairTop, chairlegs ]);
chair = L.struct2lar(chair)
View(chair)</code></pre><p>Just notice that, in expanding the <code>chair</code> data structure, <em>72 vertices</em> and <em>five 3-cells</em> are obtained. If a model made of quads or triangles is needed, just generate <code>cube</code> and <code>cylndr</code> using different <code>primitives</code> in <code>mapper.jl</code> file.</p><pre><code class="language-julia">julia&gt; chair[1]
3×72 Array{Float64,2}:
 -0.25  -0.25  -0.25  -0.25   0.25   0.25  0.25  0.25  …  -0.247716  -0.231481  -0.231481
 -0.25  -0.25   0.25   0.25  -0.25  -0.25  0.25  0.25      0.208519   0.192284   0.192284
  0.5    0.54   0.5    0.54   0.5    0.54  0.5   0.54      0.5        0.0        0.5     
julia&gt; chair[2]
5-element Array{Array{Int64,1},1}:
 [1, 2, 3, 4, 5, 6, 7, 8]                                        
 [9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24] 
 [25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40]
 [41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56]
 [57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72]</code></pre><p>Finally assemble the <code>refectory</code> model, by looping twice on a single coordinate.  Then a single <code>LAR</code> value is create, as well an <code>Array{Any,1}</code> <em>collection</em> of simplest <code>LAR</code> values, all given in <em>Wold Coordinates</em>.</p><pre><code class="language-julia">theChair = L.Struct([ L.t(-.8,0,0), chair ])
fourChairs = L.Struct( repeat([L.r(0,0,pi/2), theChair],outer=4) );
fourSit = L.Struct([fourChairs,table]);
View(fourSit)
singleRow=L.Struct(repeat([fourSit,L.t(0,2.5,0)],outer=10));
View(singleRow)
refectory=L.Struct(repeat([singleRow,L.t(3,0,0)],outer=10));
View(refectory)</code></pre><h2><a class="nav-anchor" id="Main-Interface-1" href="#Main-Interface-1">Main Interface</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebraicRepresentation.Struct" href="#LinearAlgebraicRepresentation.Struct"><code>LinearAlgebraicRepresentation.Struct</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Struct</code></pre><p>A <em>container</em> of geometrical objects is defined by applying the function <code>Struct</code> to the array of contained objects. Each value is defined in local coordinates and may be transformed by affine transformation tensors.</p><p>The value returned from the application of <code>Struct</code> to an <code>Array{Any, 1}</code> of <code>LAR</code> values, <code>matrices</code>, and <code>Struct</code> values is a value of  <code>Struct type</code>.  The coordinate system of this value is the one associated with the first object of the <code>Struct</code> arguments.  Also, the resulting geometrical value is often associated with a variable name.</p><p>The generation of containers may continue hierarchically by suitably applying <code>Struct</code>. Notice that each LAR object in a <code>Struct</code> container is transformed by each matrix before it <em>within the container</em>, going from right to left. The action of a transformation (tensor) extends to each object on its right within its own container. Whereas,  the action of a tensor does not extend outside its container, according to the semantics of <em>PHIGS</em> structures.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; L = LinearAlgebraicRepresentation;

julia&gt; assembly = L.Struct([L.sphere()(), L.t(3,0,-1), L.cylinder()()])
# return
Lar.Struct(Any[([0.0 -0.173648 … -0.336824 -0.17101; 0.0 0.0 … 0.0593912 0.0301537;
-1.0 -0.984808 … 0.939693 0.984808], Array{Int64,1}[[2, 3, 1], [4, 2, 3], [4, 3, 5], [4,
5, 6], [7, 5, 6], [7, 8, 6], [7, 9, 8], … , [1.0 0.0 0.0 3.0; 0.0 1.0 0.0 0.0; 0.0 0.0 1.0
-1.0; 0.0 0.0 0.0 1.0], ([0.5 0.5 … 0.492404 0.492404; 0.0 0.0 … -0.0868241 -0.0868241;
0.0 2.0 … 0.0 2.0], Array{Int64,1}[[4, 2, 3, 1], [4, 3, 5, 6], [7, 5, 8, 6], [7, 9, 10,
8], [9, 10, 11, 12], [13, 14, 11, 12], … , [68, 66, 67, 65], [68, 69, 67, 70], [71, 69,
72, 70], [71, 2, 72, 1]])], Array{Float64,2}[[-1.0; -1.0; -1.0], [3.5; 1.0; 1.0]],
&quot;14417445522513259426&quot;, 3, &quot;feature&quot;)

julia&gt; assembly.name = &quot;simple example&quot;
# return
&quot;simple example&quot;

julia&gt; assembly
# return
Lar.Struct(Any[([0.0 -0.173648 … -0.336824 -0.17101; 0.0 0.0 … 0.0593912 0.0301537;
-1.0 -0.984808 … 0.939693 0.984808], Array{Int64,1}[[2, 3, 1], [4, 2, 3], [4, 3, 5], [4,
5, 6], [7, 5, 6], [7, 8, 6], … , [71, 2, 72, 1]])], Array{Float64,2}[[-1.0; -1.0; -1.0],
[3.5; 1.0; 1.0]], &quot;simple example&quot;, 3, &quot;feature&quot;)

julia&gt; using Plasm

julia&gt; Plasm.view(assembly)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebraicRepresentation.apply" href="#LinearAlgebraicRepresentation.apply"><code>LinearAlgebraicRepresentation.apply</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">apply(affineMatrix::Array{Float64,2}, larmodel::Union{LAR,LARmodel})</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebraicRepresentation.struct2lar" href="#LinearAlgebraicRepresentation.struct2lar"><code>LinearAlgebraicRepresentation.struct2lar</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">struct2lar(structure::Struct)::Union{LAR,LARmodel}</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebraicRepresentation.evalStruct" href="#LinearAlgebraicRepresentation.evalStruct"><code>LinearAlgebraicRepresentation.evalStruct</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">evalStruct(self)</code></pre></div></div></section><footer><hr/><a class="previous" href="../mapper/"><span class="direction">Previous</span><span class="title">Mapper</span></a><a class="next" href="../largrid/"><span class="direction">Next</span><span class="title">Cuboidal grids</span></a></footer></article></body></html>
