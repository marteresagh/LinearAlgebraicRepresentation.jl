<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Arrangement · LinearAlgebraicRepresentation.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/lar.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="LinearAlgebraicRepresentation.jl logo"/></a><h1>LinearAlgebraicRepresentation.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../lar/">L.A.R. Intro</a></li><li><a class="toctext" href="../interface/">Interface</a></li><li class="current"><a class="toctext" href>Arrangement</a><ul class="internal"><li><a class="toctext" href="#Graph-of-recall-functions-1">Graph of recall functions</a></li><li><a class="toctext" href="#API-1">API</a></li><li><a class="toctext" href="#Theoretical-basis-1">Theoretical basis</a></li><li><a class="toctext" href="#Main-Interface-1">Main Interface</a></li></ul></li><li><span class="toctext">Parametric primitives</span><ul><li><a class="toctext" href="../mapper/">Mapper</a></li><li><a class="toctext" href="../struct/">Assemblies</a></li></ul></li><li><span class="toctext">Grid generation</span><ul><li><a class="toctext" href="../largrid/">Cuboidal grids</a></li><li><a class="toctext" href="../simplexn/">Simplicial grids</a></li></ul></li><li><a class="toctext" href="../integr/">Domain integration</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Arrangement</a></li></ul><a class="edit-page" href="https://github.com//blob/master/Downloads/LinearAlgebraicRepresentation.jl/docs/src/arrangement.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Arrangement</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Arrangement-of-cellular-complexes-1" href="#Arrangement-of-cellular-complexes-1">Arrangement of cellular complexes</a></h1><p>The <strong>arrangement</strong> is an algorithm which gets two general <span>$d$</span>-dimensional cellular complexes and arranges them in a singular <span>$d$</span>-dimensional cellular complex of which the cells respect the conditions:</p><ul><li><span>$\sigma_1 \cap \sigma_2 = \emptyset,\quad \forall$</span> couple of cells <span>$(\sigma_1, \sigma_2)$</span></li><li><span>$\bigcup_i\sigma_i = \mathbb{E}^d$</span></li></ul><p>This operation can be seen as a boolean union of two cellular complexes. Here an exploded visualization of the final result of the arrangement algorithm ran on 2 cubes made by <span>$10\times10\times10$</span> smaller cubes.</p><p><img src="../images/cube10x10.jpg" alt="10 x 10 Cube"/></p><blockquote><p><strong>Figure 1:</strong> Arrangement of <span>$2000=2\times10\times10\times10$</span> cubes</p></blockquote><h2><a class="nav-anchor" id="Graph-of-recall-functions-1" href="#Graph-of-recall-functions-1">Graph of recall functions</a></h2><p>A graph is an ordered pair <span>$G(V,E)$</span> comprising a set <span>$V$</span> of vertices, nodes or points together with a set <span>$E$</span> of edges, arcs or lines, which are <span>$2$</span>-elements subsets of <span>$V$</span>. In this case, <span>$V$</span> is the set of functions of this sub-module and let <span>$v1$</span>, <span>$v2$</span> be elements of <span>$V$</span>, then <span>$e=v1v2$</span> <span>$\in$</span> <span>$E$</span> if <span>$v1$</span> calls <span>$v2$</span>. In the following graph the functions are arranged in colored boxes: <img src="../images/dependency_graph.png" alt="dependency graph"/></p><ul><li>yellow boxes is for <code>spatial_arrangement</code></li><li>red boxes is for <code>planar_arrangement</code></li><li>green boxes is for <code>minimal_cycles</code></li><li>blue boxes is for <code>dimension_travel</code></li></ul><p>Functions in darker boxes are declared only in the local scope of its father.</p><h2><a class="nav-anchor" id="API-1" href="#API-1">API</a></h2><p>Every functions strictly relative to the arrangement has been collected in the <code>Lar.Arrangement</code> sub-module but the two main functions are accessible directly from the <code>LinearAlgebraicRepresentation</code> namespace.</p><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p><code>Lar.Arrangement</code> is the only place in <code>LinearAlgebraicRepresentation</code> where <code>Point</code> matrices store points per row and not per column as described in the documentation of <code>Lar.Points</code></p></div></div><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebraicRepresentation.spatial_arrangement" href="#LinearAlgebraicRepresentation.spatial_arrangement"><code>LinearAlgebraicRepresentation.spatial_arrangement</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">spatial_arrangement(V::Points, copEV::ChainOp, copFE::ChainOp; [multiproc::Bool])</code></pre><p>Compute the arrangement on the given cellular complex 2-skeleton in 3D.</p><p>A cellular complex is arranged when the intersection of every possible pair of cell  of the complex is empty and the union of all the cells is the whole Euclidean space. The function returns the full arranged complex as a list of vertices V and a chain of borders EV, FE, CF.</p><p><strong>Additional arguments:</strong></p><ul><li><code>multiproc::Bool</code>: Runs the computation in parallel mode. Defaults to <code>false</code>.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebraicRepresentation.planar_arrangement" href="#LinearAlgebraicRepresentation.planar_arrangement"><code>LinearAlgebraicRepresentation.planar_arrangement</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">planar_arrangement(V::Points, copEV::ChainOp, 
	[sigma::Chain], [return_edge_map::Bool], [multiproc::Bool])</code></pre><p>Compute the arrangement on the given cellular complex 1-skeleton in 2D. Whole arrangement&#39;s algorithmic pipeline. </p><p>A cellular complex is arranged when the intersection of every possible pair of cell  of the complex is empty and the union of all the cells is the whole Euclidean space. The basic method of the function without the <code>sigma</code>, <code>return_edge_map</code> and <code>multiproc</code> arguments  returns the full arranged complex <code>V</code>, <code>EV</code> and <code>FE</code>.</p><p><strong>Additional arguments:</strong></p><ul><li><code>sigma::Chain</code>: if specified, <code>planar_arrangement</code> will delete from the output every edge and face outside this cell. Defaults to an empty cell.</li><li><code>return_edge_map::Bool</code>: makes the function return also an <code>edge_map</code> which maps the edges of the imput to the one of the output. Defaults to <code>false</code>.</li><li><code>multiproc::Bool</code>: Runs the computation in parallel mode. Defaults to <code>false</code>.</li></ul></div></div></section><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Even if the arrangement algorithm is theoretically dimension independent, we implemented &quot;only&quot; the <span>$d=2$</span> and <span>$d=3$</span> version of it.</p></div></div><h2><a class="nav-anchor" id="Theoretical-basis-1" href="#Theoretical-basis-1">Theoretical basis</a></h2><p>The algorithm is based on the concept of recursive problem simplification  (a sort of <em>divide et impera</em> philosophy); if we have a <span>$d$</span>-complex, for every (<span>$d-1$</span>)-cell embedded into the <span>$\mathbb{E}^d$</span> euclidean space, we bring the cell, and every other cell that could intersect it, down into <span>$\mathbb{E}^{d-1}$</span>. We do this until we reach the <span>$d=1$</span> in <span>$\mathbb{E}^1$</span> case; in here, we fragment all the <span>$1$</span>-cells. Then, we travel back to the original <span>$d$</span>-dimension, and, for each dimensional step, we build correct complexes from cells provided by the  fragmentation of the lower dimension. </p><p><img src="../images/arrangement_steps.jpg" alt="Arrangement steps"/></p><blockquote><p><strong>Figure 2:</strong> Algorithm overview</p></blockquote><p>We have in input two cellular complexes [fig. 2, a],  given as 2-skeletons, which are the sets of 2-cells  [fig. 2, b, exploded]. Once we merged the skeletons,  we individuate for each <span>$2$</span>-cell (that we will call <span>$\sigma$</span>) all the other cells that could intersect it. We do this by computing the spatial index: it is a mapping <span>$\mathcal{I}(\sigma)$</span> from a cell  <span>$\sigma$</span> to every other cell <span>$\tau$</span> of which <span>$box(\sigma) \cap box(\tau) \neq \emptyset$</span>, where the <span>$box$</span> function provides the axis aligned bounding box (AABB) of a cell [fig. 2, c,  <span>$\sigma$</span> in red and <span>$\mathcal{I}(\sigma)$</span> in blue]. The spatial arrangement calculation is speeded up by storing the AABBs as dimensional wise intervals into an interval tree <span>$\cite{interval_trees}$</span>.  Now for each cell <span>$\sigma$</span> we transform <span>$\sigma \cup \mathcal{I}(\sigma)$</span>  in a way that <span>$\sigma$</span> lays on the <span>$x_3=0$</span>  plane [fig. 2, d] and we find the intersections  of the <span>$\mathcal{I}(\sigma)$</span> cells with <span>$x_3=0$</span>  plane. So we have a &quot;soup&quot; of 1-cells in <span>$\mathbb{E}^2$</span> [fig. 2, e], and we fragment each 1-cell  with every other cell obtaining a valid 1-skeleton [fig. 2, f]. From this data it is possible to build the 2-cells using the ALGORITHM 1 presented and explored by Paoluzzi et al. <span>$\cite{Paoluzzi}$</span> [fig. 2, g, exploded]. The procedure to fragment 1-cells on a plane and return a 2-complex is called <em>planar arrangement</em>. When the planar arrangement  is complete, fragmented <span>$\sigma$</span> can be transformed back to its original position in <span>$\mathbb{E}^3$</span>. With every 2-cell correctly fragmented, we can use the  already cited ALGORITHM 1 again to build a full 3-complex [fig. 2, h, exploded]. This is possible because ALGORITHM 1 is (almost) dimension independent.</p><h3><a class="nav-anchor" id="The-&quot;1-cells-in-\\mathbb{E}2&quot;-base-case-1" href="#The-&quot;1-cells-in-\\mathbb{E}2&quot;-base-case-1">The &quot;<span>$1$</span>-cells in <span>$\mathbb{E}^2$</span>&quot; base case</a></h3><p><img src="../images/planar_arrangement.jpg" alt="Planar arrangement overview"/></p><blockquote><p><strong>Figure 3:</strong> Planar arrangement overview</p></blockquote><p>This is our base case. We have called <em>planar arrangement</em> the procedure to handle this case since it literally arranges a bunch of edges laying on a plane. So, in input there are 1-cells in <span>$\mathbb{E}^2$</span> and, optionally (but very likely), the boundary of the original 2-cell <span>$\sigma$</span>  [fig. 3, a, <span>$\sigma$</span> in red]. We consider each edge and we fragment it with every other edge. This brings to the creation of several coincident vertices: these will be eliminated using a KD-Tree [fig. 3, b, exploded].  At this point we have a perfectly fragmented 1-complex but many edges are superfluous and must be eliminated; two kind of edges are to discard: the ones outside the area of <span>$\sigma$</span> and the ones which are not part of a maximal biconnected component  (We can talk about biconnected components because we can consider the 1-skeleton as a graph:  0-cells are nodes, 1-cells are edges and the boundary operator is a incidence matrix.). The result of this edge pruning outputs a 1-skeleton [fig. 3, c, exploded].</p><p>After this, 2-cells must be computed: For each connected component we build a containment tree, which indicates which component is spatially inside an other component. Computing these relations lets us launch the ALGORITHM 1 \cite{Paoluzzi} on each component and then combine the results to create 2-cells with non-intersecting  shells [fig. 3, d, 2-cells numbered in green; please note that cell 2 has cell 1 as an hole].</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>A 2-cell with a non-intersecting shell can be trivially defined as a &quot;face with holes&quot;; the correct definition is that it cannot  be shrunk to the dimension of a point.</p></div></div><h2><a class="nav-anchor" id="Main-Interface-1" href="#Main-Interface-1">Main Interface</a></h2><h3><a class="nav-anchor" id="Dimension-travel-1" href="#Dimension-travel-1">Dimension travel</a></h3><h3><a class="nav-anchor" id="Minimal-cycles-1" href="#Minimal-cycles-1">Minimal cycles</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebraicRepresentation.Arrangement.minimal_2cycles" href="#LinearAlgebraicRepresentation.Arrangement.minimal_2cycles"><code>LinearAlgebraicRepresentation.Arrangement.minimal_2cycles</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">minimal_2cycles(V::Lar.Points, EV::Lar.ChainOp)</code></pre><p>Return all cycles of a 2D graph define by its vertices and edges.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebraicRepresentation.Arrangement.minimal_3cycles" href="#LinearAlgebraicRepresentation.Arrangement.minimal_3cycles"><code>LinearAlgebraicRepresentation.Arrangement.minimal_3cycles</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">minimal_3cycles(V::Lar.Points, EV::Lar.ChainOp, FE::Lar.ChainOp)</code></pre></div></div></section><h3><a class="nav-anchor" id="Planar-arrangement-1" href="#Planar-arrangement-1">Planar arrangement</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebraicRepresentation.Arrangement.intersect_edges" href="#LinearAlgebraicRepresentation.Arrangement.intersect_edges"><code>LinearAlgebraicRepresentation.Arrangement.intersect_edges</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">intersect_edges(V::Lar.Points, edge1::Lar.Cell, edge2::Lar.Cell)</code></pre><p>Intersection of two edges. Return, if exist, points of intersection and parameter.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; V=[0 0 ; 1 1; 1/2 0; 1/2 1];

julia&gt; EV = SparseArrays.sparse(Array{Int8, 2}([
                            [1 1 0 0] #1-&gt;1,2
                            [0 0 1 1] #2-&gt;3,4       
                        ]));

julia&gt; Lar.Arrangement.intersect_edges(V, EV[1, :], EV[2, :])
1-element Array{Tuple{Array{T,2} where T,Float64},1}:
 ([0.5 0.5], 0.5)
</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebraicRepresentation.Arrangement.frag_edge" href="#LinearAlgebraicRepresentation.Arrangement.frag_edge"><code>LinearAlgebraicRepresentation.Arrangement.frag_edge</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">frag_edge(V::Lar.Points, EV::Lar.ChainOp, edge_idx::Int, bigPI)</code></pre><p>Return vertices and edges after intersection.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; V = [ 0 0; 1 1; 1 0; 0 1];

julia&gt; EV = Int8[ 1 1 0 0;
                  0 0 1 1; 
                  ];

julia&gt; EV = sparse(EV);

julia&gt; model = (convert(Lar.Points,V&#39;),Lar.cop2lar(EV));

julia&gt; bigPI = Lar.spaceindex(model::Lar.LAR);

julia&gt; Lar.Arrangement.frag_edge(V, EV, 1, bigPI)
([0.0 0.0; 1.0 1.0; 0.5 0.5], 
  [1, 1]  =  1
  [2, 2]  =  1
  [1, 3]  =  1
  [2, 3]  =  1)

julia&gt; Lar.Arrangement.frag_edge(V, EV, 2, bigPI)
([1.0 0.0; 0.0 1.0; 0.5 0.5], 
  [1, 1]  =  1
  [2, 2]  =  1
  [1, 3]  =  1
  [2, 3]  =  1)

</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebraicRepresentation.Arrangement.merge_vertices!" href="#LinearAlgebraicRepresentation.Arrangement.merge_vertices!"><code>LinearAlgebraicRepresentation.Arrangement.merge_vertices!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">merge_vertices!(V::Lar.Points, EV::Lar.ChainOp, edge_map, err=1e-4)</code></pre><p>If two or more vertices are very close, return one vertex and right edges. </p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; p0 = 1e-2;

julia&gt; pm = 1-p0;

julia&gt; pp = 1+p0;

julia&gt; V = [ p0  p0; p0 -p0;
                    pp pm; pp pp
                  ];

julia&gt; EV = Int8[1 0 1 0 ;
                 0 1 0 1 ;
                 1 0 0 1 ;
                 0 1 1 0 ];

julia&gt; EV = sparse(EV);

julia&gt; Lar.Arrangement.merge_vertices!(V, EV, [],1e-1)
([0.01 0.01; 1.01 0.99], 
  [1, 1]  =  1
  [1, 2]  =  1)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebraicRepresentation.Arrangement.biconnected_components" href="#LinearAlgebraicRepresentation.Arrangement.biconnected_components"><code>LinearAlgebraicRepresentation.Arrangement.biconnected_components</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">biconnected_components(EV::Lar.ChainOp)</code></pre><p>Find the biconnected components of a graph define by his edges. A biconnected component is a maximal biconnected subgraph. A biconnected graph has no <strong>articulation vertices</strong>. </p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; EV = Int8[1 1 0 0 0 0;
               0 1 1 0 0 0;
               1 0 1 0 0 0;
               1 0 0 0 1 0;
               0 0 0 1 1 0;
               0 0 0 1 0 1;
               0 0 0 0 1 1] ;

julia&gt; EV = sparse(EV);

julia&gt; bc = Lar.Arrangement.biconnected_components(EV)
2-element Array{Array{Int64,1},1}:
 [3, 2, 1]
 [7, 6, 5]</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebraicRepresentation.Arrangement.get_external_cycle" href="#LinearAlgebraicRepresentation.Arrangement.get_external_cycle"><code>LinearAlgebraicRepresentation.Arrangement.get_external_cycle</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">get_external_cycle(V::Lar.Points, EV::Lar.ChainOp, FE::Lar.ChainOp)</code></pre><p>Get the face&#39;s index of external cell in FE. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebraicRepresentation.Arrangement.pre_containment_test" href="#LinearAlgebraicRepresentation.Arrangement.pre_containment_test"><code>LinearAlgebraicRepresentation.Arrangement.pre_containment_test</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">pre_containment_test(bboxes)</code></pre><p>Return containment graph. An element <strong>(i,j)</strong> is <strong>1</strong> if the <strong>i-th</strong> cell is contained in the <strong>boundary box</strong> of the <strong>j-th</strong> cell.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebraicRepresentation.Arrangement.prune_containment_graph" href="#LinearAlgebraicRepresentation.Arrangement.prune_containment_graph"><code>LinearAlgebraicRepresentation.Arrangement.prune_containment_graph</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">prune_containment_graph(n, V, EVs, shells, graph)</code></pre><p>Check if the origin point of a cell is inside the face area of other cell in the graph.   </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebraicRepresentation.Arrangement.transitive_reduction!" href="#LinearAlgebraicRepresentation.Arrangement.transitive_reduction!"><code>LinearAlgebraicRepresentation.Arrangement.transitive_reduction!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">transitive_reduction!(graph)</code></pre><p>Remove elements from containment graph that can be compute for transitivity.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; graph = [0 1 1 1 ; 0 0 1 1 ; 0 0 0 1 ; 0 0 0 0 ];

julia&gt; Lar.Arrangement.transitive_reduction!(graph)

julia&gt; graph
4×4 Array{Int64,2}:
 0  1  0  0
 0  0  1  0
 0  0  0  1
 0  0  0  0
</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebraicRepresentation.Arrangement.componentgraph" href="#LinearAlgebraicRepresentation.Arrangement.componentgraph"><code>LinearAlgebraicRepresentation.Arrangement.componentgraph</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">componentgraph(V, copEV, bicon_comps)</code></pre><p>Return some properties of a graph, in order: <code>n</code>, <code>containment_graph</code>, <code>V</code>, <code>EVs</code>, <code>boundaries</code>, <code>shells</code>, <code>shell_bboxes</code>. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebraicRepresentation.Arrangement.cell_merging" href="#LinearAlgebraicRepresentation.Arrangement.cell_merging"><code>LinearAlgebraicRepresentation.Arrangement.cell_merging</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">cell_merging(n, containment_graph, V, EVs, boundaries, shells, shell_bboxes)</code></pre><p>Merge all cells.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebraicRepresentation.Arrangement.cleandecomposition" href="#LinearAlgebraicRepresentation.Arrangement.cleandecomposition"><code>LinearAlgebraicRepresentation.Arrangement.cleandecomposition</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">cleandecomposition(V, copEV, sigma)</code></pre><p>Delete edges outside sigma area.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebraicRepresentation.Arrangement.planar_arrangement_1" href="#LinearAlgebraicRepresentation.Arrangement.planar_arrangement_1"><code>LinearAlgebraicRepresentation.Arrangement.planar_arrangement_1</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">function planar_arrangement_1( V::Lar.Points, copEV::Lar.ChainOp, 
	sigma::Lar.Chain=spzeros(Int8, 0), 
	return_edge_map::Bool=false, 
	multiproc::Bool=false)</code></pre><p>Compute the arrangement on the given cellular complex 1-skeleton in 2D. First part of arrangement&#39;s algorithmic pipeline. </p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebraicRepresentation.Arrangement.planar_arrangement_2" href="#LinearAlgebraicRepresentation.Arrangement.planar_arrangement_2"><code>LinearAlgebraicRepresentation.Arrangement.planar_arrangement_2</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">function planar_arrangement_2(V, copEV, bicon_comps, 
	sigma::Lar.Chain=spzeros(Int8, 0), 
	return_edge_map::Bool=false, 
	multiproc::Bool=false)</code></pre><p>Compute the arrangement on the given cellular complex 1-skeleton in 2D. Second part of arrangement&#39;s algorithmic pipeline. </p></div></div></section><h3><a class="nav-anchor" id="Spatial-arrangement-1" href="#Spatial-arrangement-1">Spatial arrangement</a></h3><footer><hr/><a class="previous" href="../interface/"><span class="direction">Previous</span><span class="title">Interface</span></a><a class="next" href="../mapper/"><span class="direction">Next</span><span class="title">Mapper</span></a></footer></article></body></html>
