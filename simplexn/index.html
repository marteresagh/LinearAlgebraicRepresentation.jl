<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Simplicial grids · LinearAlgebraicRepresentation.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/lar.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="LinearAlgebraicRepresentation.jl logo"/></a><h1>LinearAlgebraicRepresentation.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../lar/">L.A.R. Intro</a></li><li><a class="toctext" href="../interface/">Interface</a></li><li><a class="toctext" href="../arrangement/">Arrangement</a></li><li><span class="toctext">Parametric primitives</span><ul><li><a class="toctext" href="../mapper/">Mapper</a></li><li><a class="toctext" href="../struct/">Assemblies</a></li></ul></li><li><span class="toctext">Grid generation</span><ul><li><a class="toctext" href="../largrid/">Cuboidal grids</a></li><li class="current"><a class="toctext" href>Simplicial grids</a><ul class="internal"><li><a class="toctext" href="#Examples-1">Examples</a></li><li><a class="toctext" href="#Main-Interface-1">Main Interface</a></li></ul></li></ul></li><li><a class="toctext" href="../integr/">Domain integration</a></li></ul></nav><article id="docs"><header><nav><ul><li>Grid generation</li><li><a href>Simplicial grids</a></li></ul><a class="edit-page" href="https://github.com//blob/master/Downloads/LinearAlgebraicRepresentation.jl/docs/src/simplexn.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Simplicial grids</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Simplicial-complexes-1" href="#Simplicial-complexes-1">Simplicial complexes</a></h1><p>This module defines a minimal set of functions to generate a <em>dimension-independent</em> cellular complex of simplices. The name of the library was firstly used by  CAD Lab at University <span>$La Sapienza$</span> of Rome  in years 1987/88 when started working with dimension-independent simplicial complexes (see &quot;<a href="https://dl.acm.org/citation.cfm?doid=169728.169719">Dimension-independent modeling with simplicial complexes</a>&quot; ). The library provides  <strong>combinatorial algorithms</strong> for some basic functions of <em>geometric modelling with simplicial complexes</em>. In particular, provides the efficient creation of simplicial complexes generated by simplicial complexes of lower dimension, the production of simplicial grids of any dimension, and the extraction of <em>facets</em> (i.e. of <span>$(d-1)$</span>-faces) of simplicial of <span>$d$</span>-complexes. The main aim of the simplicial functions given in this library is to provide <em>optimal combinatorial algorithms</em>, whose time complexity is linear in the size of the output. Such a goal is achieved by calculating each cell in the output via <em>closed combinatorial formulas</em>, that do not require any searching nor data structure traversal to produce their results.</p><h3><a class="nav-anchor" id="Simplicial-extrusion-1" href="#Simplicial-extrusion-1">Simplicial extrusion</a></h3><p>Here we discuss the implementation of the linear extrusion of simplicial complexes according to the method discussed on papers &quot;<a href="https://dl.acm.org/citation.cfm?doid=169728.169719">Dimension-independent modeling with simplicial complexes</a>&quot; and &quot;<a href="https://www.sciencedirect.com/science/article/pii/001044859190080G">Extrusion and boundary evaluation for multidimensional polyhedra</a>&quot;. In synthesis, for each <span>$d$</span>-simplex in the input complex, we generate combinatorially a <span>$(d+1)$</span>-simplicial <em>tube</em>, i.e. a chain of <span>$d+1$</span> simplexes of dimension <span>$d+1$</span>. It can be shown that if the input simplices are a simplicial complex, then the output simplices are a simplicial complex too (i.e. are correctly glued together). </p><p>In other words, if the input is a <span>$d$</span>complex, where all <span>$d$</span>-cells either intersect along a common face or are pairwise disjoints, then the output is  a simplicial complex of dimension <span>$d+1$</span>. This method is <strong>computationally optimal</strong>, since it does not require any search or traversal of data structures. The algorithm just writes the output making a constant number <span>$O(1)$</span> of operation for each one of its <span>$n$</span> output <span>$d$</span>-cells, so that the time complexity is <span>$\Omega(n)$</span>, where <span>$n = d\,m$</span>, being <span>$m$</span> the number and <span>$d$</span> the dimension (and the storage size) of the input cells, represented as arrays of indices of vertices, using the <code>Cells</code> type.</p><p>The aim of the <code>extrudeSimplicial</code> function is  to generate the output model vertices and cells in a <em>multiple</em> extrusion of a LAR model. First note that the <code>model</code> variable contains a pair (<code>V</code>, <code>FV</code>), where <code>V</code> is the array of input vertices, and <code>FV</code> is the array of <span>$d$</span>-cells (given as list of lists of vertex indices), providing the  input representation of a LAR cellular complex. The <code>pattern</code> variable is a list of integers, whose absolute values provide the sizes of the ordered set of 1D subintervals (in local coords) specified by the <code>pattern</code> itself. Such subintervals are assembled in global coordinates, and each one of them is considered either <em>solid</em> or <em>empty</em> depending on the sign of the corresponding measure, which may be either positive (solid subinterval) or negative (void subinterval).  </p><p>Therefore, a value <code>pattern = [1,1,-1,1]</code> is interpreted as the 1D simplicial complex</p><p><code>[0,1]</code> <span>$\cup$</span> <code>[1,2]</code> <span>$\cup$</span> <code>[3,4]</code></p><p>with five vertices <code>W = [[0.0], [1.0], [2.0], [3.0], [4.0]]</code> and three 1-cells <code>[[0,1], [1,2], [3,4]]</code>.</p><p><code>V</code> is the list of input <span>$d$</span>-vertices (each given as a list of <span>$d$</span> coordinates); <code>coords</code> is a list of absolute translation parameters to be applied to <code>V</code> in order to generate the output vertices generated by the combinatorial extrusion algorithm. The <code>cellGroups</code> internal variable is used to select the groups of <span>$(d+1)$</span>-simplices corresponding to solid intervals in the input <code>pattern</code>.</p><h3><a class="nav-anchor" id="Simplicial-grids-1" href="#Simplicial-grids-1">Simplicial grids</a></h3><p>The generation of simplicial grids of any dimension and shape using the <code>simplexGrid</code> is amazingly simple. The input parameter <code>shape</code> is either a tuple or a list of integers used to specify the <em>shape</em> of the created array, i.e. both the number of its dimensions (given by <code>len(shape)</code>) and the <code>size</code> of each dimension <span>$k$</span> (given by the <code>shape[k]</code> element). The implementation starts from the LAR model of an empty simplicial  model (denoted as <code>VOID</code>, a predefined constant) and updates the <code>model</code> variable extruding it iteratively according to the specs given by <code>shape</code>. Just notice that the returned grid <code>model</code>usually has vertices with integer coordinates, that can be subsequently scaled and/or translated and/or mapped in any other way, according to the user needs.</p><h3><a class="nav-anchor" id="Facet-extraction-from-simplices-1" href="#Facet-extraction-from-simplices-1">Facet extraction from simplices</a></h3><p>A <span>$k$</span>-face of a <span>$d$</span>-simplex is defined as the convex hull of any subset of <span>$k$</span> vertices. A <span>$(d-1)$</span>-face of a <span>$d$</span>-simplex </p><p><span>$\sigma^d = \langle v_0, v_1, \ldots, v_d \rangle$</span></p><p>is also called a <em>facet</em>. Each of the <span>$d+1$</span> facets of <span>$\sigma^d$</span>, obtained by removing a vertex from <span>$\sigma^d$</span>, is a <span>$(d-1)$</span>-simplex. A simplex may be oriented in two different ways according to the permutation class of its vertices. The simplex <em>orientation</em> is so changed by either multiplying the simplex by -1, or by executing an odd number of exchanges of its vertices. </p><p>The chain of oriented boundary facets of <span>$\sigma^d$</span>, usually denoted as <span>$\partial \sigma^d$</span>, is generated combinatorially as follows:</p><p><span>$\partial\, \sigma^d = \sum_{k=0}^d (-1)^d \langle v_0, \ldots, v_{k-1}, v_{k+1}, \ldots, v_d \rangle$</span></p><p>The <code>larSimplexFacets</code> function, for estraction of non-oriented <span>$(d-1)$</span>-facets of <span>$d$</span>-dimensional simplices, returns a list of <span>$d$</span>-tuples of integers, i.e. the input LAR representation of the topology of a cellular complex. The final steps are used to remove the duplicated facets, by transforming the sorted facets into a <em>set of strings</em>, so removing the duplicated elements.</p><h2><a class="nav-anchor" id="Examples-1" href="#Examples-1">Examples</a></h2><h3><a class="nav-anchor" id="Multidimensional-simplicial-extrusion-1" href="#Multidimensional-simplicial-extrusion-1">Multidimensional simplicial extrusion</a></h3><p>The algorithm for multimensional extrusion of a simplicial complex is implemented in the <code>extrudeSimplicial</code> function.  This one can be applied to 0-, 1-, 2-, ... simplicial <code>model</code>, to get a 1-, 2-, 3-, .... <code>model</code>.  A 1D <code>pattern</code> of linear <code>Array</code> type is used to specify how to decompose the added dimension.</p><p>The input and output <code>model</code> are a LAR model, i.e. a pair <code>(vertices, cells)</code>, whereas <code>pattern</code> is an array of <code>Int64</code>, to be used as lateral measures of the <em>extruded</em> model. Note that <code>pattern</code> elements are assumed as either <em>solid</em> or <em>empty</em> measures, according to their (+/-) sign.</p><pre><code class="language-julia">julia&gt; Lar = LinearAlgebraicRepresentation

julia&gt; V = [[0,0] [1,0] [2,0] [0,1] [1,1] [2,1] [0,2] [1,2] [2,2]]
2×9 Array{Int64,2}:
 0  1  2  0  1  2  0  1  2
 0  0  0  1  1  1  2  2  2

julia&gt; FV = [[1,2,4],[2,3,5],[3,5,6],[4,5,7],[5,7,8],[6,8,9]]
6-element Array{Array{Int64,1},1}:
 [1, 2, 4]
 [2, 3, 5]
 [3, 5, 6]
 [4, 5, 7]
 [5, 7, 8]
 [6, 8, 9]

julia&gt; pattern = repeat([1,2,-3],outer=4)
12-element Array{Int64,1}:
[1,2,-3,1,2,-3,1,2,-3,1,2,-3]

julia&gt; model = (V,FV)
([0 1 2 0 1 2 0 1 2; 0 0 0 1 1 1 2 2 2], 
Array{Int64,1}[[1, 2, 4], [2, 3, 5], [3, 5, 6], [4, 5, 7], [5, 7, 8], [6, 8, 9]])

julia&gt; W,FW = Lar.extrudeSimplicial(model, pattern)

julia&gt; W
3×117 Array{Int64,2}:
 0  1  2  0  1  2  0  1  2   …   0   1   2   0   1   2   0   1   2   0   1   2
 0  0  0  1  1  1  2  2  2       2   2   2   0   0   0   1   1   1   2   2   2
 0  0  0  0  0  0  0  0  0      21  21  21  24  24  24  24  24  24  24  24  24

julia&gt; FW
144-element Array{Array{Int64,1},1}:
 [1, 2, 4, 10]      
 [2, 4, 10, 11]     
 ⋮                  
 [96, 98, 99, 105]  
 [98, 99, 105, 107] 
 [99, 105, 107, 108]

julia&gt; Plasm.view(W,FW)</code></pre><h3><a class="nav-anchor" id="Multidimensional-grids-of-simplices-1" href="#Multidimensional-grids-of-simplices-1">Multidimensional grids of simplices</a></h3><p>Generate a simplicial complex decomposition of a cubical grid of <span>$d$</span>-cuboids, where <span>$d$</span> is the length of <code>shape=[</code><code>n_1, n_2, ..., n_d</code><code>]</code> array, so that <code>shape</code> defines the grid dimension <span>$d$</span> and size <span>$n_1 \times n_2 \times ... \times n_d$</span>  as a <span>$d$</span>-dimensional array of <em>cubes</em>. Vertices (0-cells) of the grid have <code>Int64</code> coordinates.</p><pre><code class="language-julia">julia&gt; Lar.simplexGrid([0]) # 0-dimensional simplicial complex
# output
([0], Array{Int64,1}[])

julia&gt; V,EV = Lar.simplexGrid([1]) # 1-dimensional simplicial complex
# output
([0 1], Array{Int64,1}[[1, 2]])

julia&gt; V,FV = Lar.simplexGrid([1,1]) # 2-dimensional simplicial complex
# output
([0 1 0 1; 0 0 1 1], Array{Int64,1}[[1, 2, 3], [2, 3, 4]])

julia&gt; V,CV = Lar.simplexGrid([10,10,1]) # 3-dimensional simplicial complex
# output
([0 1 … 9 10; 0 0 … 10 10; 0 0 … 1 1], Array{Int64,1}[[1, 2, 12, 122], [2, 12, 122, 123], [12, 122, 123, 133], [2, 12, 13, 123], [12, 13, 123, 133], [13, 123, 133, 134], [2, 3, 13, 123], [3, 13, 123, 124], [13, 123, 124, 134], [3, 13, 14, 124]  …  [119, 229, 230, 240], [109, 119, 120, 230], [119, 120, 230, 240], [120, 230, 240, 241], [109, 110, 120, 230], [110, 120, 230, 231], [120, 230, 231, 241], [110, 120, 121, 231], [120, 121, 231, 241], [121, 231, 241, 242]])

julia&gt; V
# output
3×242 Array{Int64,2}:
 0  1  2  3  4  5  6  7  8  9  10  0  1  2  3  …   1   2   3   4   5   6   7   8   9  10
 0  0  0  0  0  0  0  0  0  0   0  1  1  1  1     10  10  10  10  10  10  10  10  10  10
 0  0  0  0  0  0  0  0  0  0   0  0  0  0  0      1   1   1   1   1   1   1   1   1   1


julia&gt; using Plasm

julia&gt; hpc = Plasm.hpc_exploded(V,CV) # exploded visualization of the simplicial grid

julia&gt; Plasm.view(hpc)

julia&gt; V,HV = simplexGrid([1,1,1,1]) # 4-dim simplicial complex
# output
([0 1 … 0 1; 0 0 … 1 1; 0 0 … 1 1; 0 0 … 1 1], Array{Int64,1}[[1, 2, 3, 5, 9], [2, 3, 5, 9, 10], [3, 5, 9, 10, 11], [5, 9, 10, 11, 13], [2, 3, 5, 6, 10], [3, 5, 6, 10, 11], [5, 6, 10, 11, 13], [6, 10, 11, 13, 14], [3, 5, 6, 7, 11], [5, 6, 7, 11, 13]  …  [4, 6, 10, 11, 12], [6, 10, 11, 12, 14], [3, 4, 6, 7, 11], [4, 6, 7, 11, 12], [6, 7, 11, 12, 14], [7, 11, 12, 14, 15], [4, 6, 7, 8, 12], [6, 7, 8, 12, 14], [7, 8, 12, 14, 15], [8, 12, 14, 15, 16]])</code></pre><h3><a class="nav-anchor" id="Facets-of-multidimensional-simplicial-complexes-1" href="#Facets-of-multidimensional-simplicial-complexes-1">Facets of multidimensional simplicial complexes</a></h3><p>Compute the <code>(d-1)</code>-skeleton (set of <code>facets</code>) of a simplicial <code>d</code>-complex. Each of the <span>$d+1$</span> facets of of a <span>$d$</span>-simplex <span>$\sigma^d$</span>, obtained by removing a vertex from <span>$\sigma^d$</span>, is a <span>$(d-1)$</span>-simplex.</p><pre><code class="language-julia">julia&gt; V,FV = Lar.simplexGrid([1,1]) # 2-dimensional complex
# output
([0 1 0 1; 0 0 1 1], Array{Int64,1}[[1, 2, 3], [2, 3, 4]])

julia&gt; Plasm.view(V,FV)

julia&gt; W,CW = Lar.extrudeSimplicial((V,FV), [1])
([0.0 1.0 … 0.0 1.0; 0.0 0.0 … 1.0 1.0; 0.0 0.0 … 1.0 1.0], 
Array{Int64,1}[[1,2,3,5],[2,3,5,6],[3,5,6,7],[2,3,4,6],[3,4,6,7],[4,6,7,8]])

julia&gt; FW = Lar.simplexFacets(CW)
18-element Array{Any,1}:
[[1,3,5],[5,6,7],[3,5,7],[3,6,7],[4,6,7],[4,7,8],[4,6,8],
[6,7,8],[3,5,6],[2,3,5],[2,3,4],[3,4,7],[1,2,3],[2,4,6],[2,5,6],
[1,2,5],[2,3,6],[3,4,6]]

julia&gt; Plasm.view(W,FW)</code></pre><h2><a class="nav-anchor" id="Main-Interface-1" href="#Main-Interface-1">Main Interface</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebraicRepresentation.simplexGrid" href="#LinearAlgebraicRepresentation.simplexGrid"><code>LinearAlgebraicRepresentation.simplexGrid</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">simplexGrid(shape::Array)::LAR</code></pre><p>Generate a simplicial complex decomposition of a cubical grid of <span>$d$</span>-cuboids, where <span>$d$</span> is the length of <code>shape</code> array. Vertices (0-cells) of the grid have <code>Int64</code> coordinates.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; simplexGrid([0]) # 0-dimensional complex
# output
([0], Array{Int64,1}[])

julia&gt; V,EV = simplexGrid([1]) # 1-dimensional complex
# output
([0 1], Array{Int64,1}[[1, 2]])

julia&gt; V,FV = simplexGrid([1,1]) # 2-dimensional complex
# output
([0 1 0 1; 0 0 1 1], Array{Int64,1}[[1, 2, 3], [2, 3, 4]])

julia&gt; V,CV = simplexGrid([10,10,1]) # 3-dimensional complex
# output
([0 1 … 9 10; 0 0 … 10 10; 0 0 … 1 1], Array{Int64,1}[[1, 2, 12, 122], [2, 12, 122, 123], [12, 122, 123, 133], [2, 12, 13, 123], [12, 13, 123, 133], [13, 123, 133, 134], [2, 3, 13, 123], [3, 13, 123, 124], [13, 123, 124, 134], [3, 13, 14, 124]  …  [119, 229, 230, 240], [109, 119, 120, 230], [119, 120, 230, 240], [120, 230, 240, 241], [109, 110, 120, 230], [110, 120, 230, 231], [120, 230, 231, 241], [110, 120, 121, 231], [120, 121, 231, 241], [121, 231, 241, 242]])

julia&gt; V
# output
3×242 Array{Int64,2}:
 0  1  2  3  4  5  6  7  8  9  10  0  1  2  3  …   1   2   3   4   5   6   7   8   9  10
 0  0  0  0  0  0  0  0  0  0   0  1  1  1  1     10  10  10  10  10  10  10  10  10  10
 0  0  0  0  0  0  0  0  0  0   0  0  0  0  0      1   1   1   1   1   1   1   1   1   1

julia&gt; using Plasm

julia&gt; hpc = Plasm.lar2exploded_hpc(V,CV) # exploded visualization of the grid

julia&gt; Plasm.view(hpc)

julia&gt; V,HV = simplexGrid([1,1,1,1]) # 4-dim cellular complex from the 4D simplex
# output
([0 1 … 0 1; 0 0 … 1 1; 0 0 … 1 1; 0 0 … 1 1], Array{Int64,1}[[1, 2, 3, 5, 9], [2, 3, 5, 9, 10], [3, 5, 9, 10, 11], [5, 9, 10, 11, 13], [2, 3, 5, 6, 10], [3, 5, 6, 10, 11], [5, 6, 10, 11, 13], [6, 10, 11, 13, 14], [3, 5, 6, 7, 11], [5, 6, 7, 11, 13]  …  [4, 6, 10, 11, 12], [6, 10, 11, 12, 14], [3, 4, 6, 7, 11], [4, 6, 7, 11, 12], [6, 7, 11, 12, 14], [7, 11, 12, 14, 15], [4, 6, 7, 8, 12], [6, 7, 8, 12, 14], [7, 8, 12, 14, 15], [8, 12, 14, 15, 16]])</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebraicRepresentation.simplexFacets" href="#LinearAlgebraicRepresentation.simplexFacets"><code>LinearAlgebraicRepresentation.simplexFacets</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">simplexFacets(simplices::Cells)::Cells</code></pre><p>Compute the <code>(d-1)</code>-skeleton (unoriented set of <code>facets</code>) of a simplicial <code>d</code>-complex.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; V,FV = Lar.simplexGrid([1,1]) # 2-dimensional complex
# output
([0 1 0 1; 0 0 1 1], Array{Int64,1}[[1, 2, 3], [2, 3, 4]])

julia&gt; Plasm.view(V,FV)

julia&gt; W,CW = Lar.extrudeSimplicial((V,FV), [1])
([0.0 1.0 … 0.0 1.0; 0.0 0.0 … 1.0 1.0; 0.0 0.0 … 1.0 1.0], 
Array{Int64,1}[[1,2,3,5],[2,3,5,6],[3,5,6,7],[2,3,4,6],[3,4,6,7],[4,6,7,8]])

julia&gt; FW = Lar.simplexFacets(CW)
18-element Array{Any,1}:
[[1,3,5],[5,6,7],[3,5,7],[3,6,7],[4,6,7],[4,7,8],[4,6,8],
[6,7,8],[3,5,6],[2,3,5],[2,3,4],[3,4,7],[1,2,3],[2,4,6],[2,5,6],
[1,2,5],[2,3,6],[3,4,6]]

julia&gt; Plasm.view(W,FW)</code></pre><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; V,(VV,EV,FV,CV) = Lar.cuboidGrid([3,3,3],true)

julia&gt; TV = Lar.simplexFacets(CV)

julia&gt; Plasm.view(V,TV)
</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebraicRepresentation.extrudeSimplicial" href="#LinearAlgebraicRepresentation.extrudeSimplicial"><code>LinearAlgebraicRepresentation.extrudeSimplicial</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">extrudeSimplicial(model::LAR, pattern::Array)::LAR</code></pre><p>Algorithm for multimensional extrusion of a simplicial complex.  Can be applied to 0-, 1-, 2-, ... simplicial models, to get a 1-, 2-, 3-, .... model. The pattern <code>Array</code> is used to specify how to decompose the added dimension.</p><p>A <code>model</code> is a LAR model, i.e. a pair (vertices,cells) to be extruded, whereas pattern is an array of <code>Int64</code>, to be used as lateral measures of the <em>extruded</em> model. <code>pattern</code> elements are assumed as either <em>solid</em> or <em>empty</em> measures, according to their (+/-) sign.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; V = [[0,0] [1,0] [2,0] [0,1] [1,1] [2,1] [0,2] [1,2] [2,2]];

julia&gt; FV = [[1,2,4],[2,3,5],[3,5,6],[4,5,7],[5,7,8],[6,8,9]];

julia&gt; pattern = repeat([1,2,-3],outer=4);

julia&gt; model = (V,FV);

julia&gt; W,FW = extrudeSimplicial(model, pattern);

julia&gt; Plasm.view(W,FW)</code></pre></div></div></section><footer><hr/><a class="previous" href="../largrid/"><span class="direction">Previous</span><span class="title">Cuboidal grids</span></a><a class="next" href="../integr/"><span class="direction">Next</span><span class="title">Domain integration</span></a></footer></article></body></html>
